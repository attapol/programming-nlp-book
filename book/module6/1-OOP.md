# บทที่ 6 </br> การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming)

สมมติว่าเราต้องการเก็บข้อมูลของคำแต่ละคำที่อยู่ในย่อหน้าย่อหน้าหนึ่ง  โครงสร้างข้อมูลที่เหมาะกับข้อมูลประเภทนี้ คือ ลิสต์ที่เก็บสตริง เช่น
```python
paragraph = ['Apple', 'Inc.' 'is' 'an' 'American' 'multinational' 'technology' 'firm'  'headquartered', 'in' 'Cupertino', 'California' '.']
```
แต่สมมติอีกว่าเราต้องการเก็บข้อมูลของแต่ละคำอย่างละเอียดขึ้น เช่น ประเภทของคำ (part-of-speech tag) ประเภทของชื่อเฉพาะ (named entity tag) คำนี้เป็นภาษาอะไร คำนี้เป็นคำที่ขึ้นต้นประโยคหรือไม่ คำนี้มีรูปก่อนการผันรูปเป็นอะไร (lemma)   โครงสร้างข้อมูลที่เหมาะกับข้อมูลประเภทนี้ คือ ลิสต์ของดิกชันนารี เช่น
```python
paragraph = [
    {'word': 'Apple', 'pos': 'NNP', 'ner': 'ORG', 'lang': 'en', 'is_first': True, 'lemma': 'apple'},
    {'word': 'Inc.', 'pos': 'NNP', 'ner': 'ORG', 'lang': 'en', 'is_first': False, 'lemma': 'inc.'},
    {'word': 'is', 'pos': 'VBZ', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'be'},
    {'word': 'an', 'pos': 'DT', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'an'},
    {'word': 'American', 'pos': 'JJ', 'ner': 'MISC', 'lang': 'en', 'is_first': False, 'lemma': 'american'},
    {'word': 'multinational', 'pos': 'JJ', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'multinational'},
    {'word': 'technology', 'pos': 'NN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'technology'},
    {'word': 'firm', 'pos': 'NN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'firm'},
    {'word': 'headquartered', 'pos': 'VBN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'headquarter'},
    {'word': 'in', 'pos': 'IN', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': 'in'},
    {'word': 'Cupertino', 'pos': 'NNP', 'ner': 'LOC', 'lang': 'en', 'is_first': False, 'lemma': 'cupertino'},
    {'word': 'California', 'pos': 'NNP', 'ner': 'LOC', 'lang': 'en', 'is_first': False, 'lemma': 'california'},
    {'word': '.', 'pos': '.', 'ner': 'O', 'lang': 'en', 'is_first': False, 'lemma': '.'}
]
```
อย่างแรกที่เราสังเกตได้คือ ดิกชันนารีที่เราใช้มีฟิลด์ถึง 6 ฟิลด์ การจะเขียนโปรแกรมขึ้นมาเพื่อประมวลผลวิเคราะห์ข้อมูลประเภทนี้ เราจะต้องระวังว่าดิกชันนารีแต่ละอันที่เก็บข้อมูลของคำจะต้องมีฟิลด์เท่ากันหมด และผู้ที่เขียนฟังก์ชันเพื่อประมวลผลดิกชันนารีจะต้องทราบด้วยว่าฟิลด์เหล่านี้มีอะไรบ้าง เก็บอะไรไว้บ้าง ถ้าหากมีการเปลี่ยนแปลงชื่อฟิลด์ หรือเพิ่มฟิลด์ใหม่ ฟังก์ชันที่เขียนขึ้นมาเพื่อประมวลผลดิกชันนารีจะต้องถูกแก้ไขใหม่ทั้งหมด ซึ่งอาจจะทำให้เกิดข้อผิดพลาดได้ เพราะว่าโค้ดที่ใช้ในการสร้างดิกชันนารีขึ้นมา กับโค้ดที่ใช้ในการประมวลผลอาจจะอยู่คนละที่ คนละไฟล์กัน ทำให้โค้ดที่เขียนขึ้นมานั้นยากต่อการบำรุงรักษา และยากต่อการเปลี่ยนแปลง 

## คลาส (class) และอ็อบเจกต์ (object)
การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming: OOP) คือหลักการที่เราจะใช้ในการออกแบบโครงสร้างข้อมูลเพื่อให้สะดวกกับกรณีการใช้งานดังตัวอย่างข้างต้น หลักการของ OOP คือการออกแบบโครงสร้างข้อมูลขี้นมาเป็นพิเศษ เจาะจงกับข้อมูลที่เราต้องการจะเก็บ โครงสร้างข้อมูลนี้เรียกว่าคลาส (class) 

คลาสในภาษาไพทอน[^pythonoop] ประกอบลักษณะพิเศษหลัก ๆ 3 อย่าง คือ

1. ลักษณะประจำ (attribute) 
2. เมท็อด (method) ซึ่งเป็นโค้ดที่ใช้ประมวลผลลักษณะประจำคลาส 
3. สิ่งสืบทอด (inheritance) ซึ่งใช้ดึงเอาเมท็อดจากคลาสอื่นมาใช้ 

## ลักษณะประจำ (attribute)
ลักษณะประจำ เป็นตัวแปรที่เก็บซ้อนอยู่ในคลาส ใช้เก็บข้อมูลคล้ายคลึงกับตัวแปร เพื่อให้เห็นภาพมากขึ้น เราจะลองเขียนคลาสเพื่อใช้เก็บข้อมูลเกี่ยวกับคำในประโยคแทนที่ดิกชันนารี เราขอเรียกว่าโทเค็น (token) แทนที่คำว่า *คำ* [^token] โทเค็น หมายถึง หน่วยหนึ่งหน่วยที่ผู้วิเคราะห์ใช้เป็นหน่วยที่เล็กที่สุดในการประมวลผล ตัวอย่างโค้ดในการกำหนดคลาสมีดังนี้

[^pythonoop]: ไพทอนไม่ได้สนับสนุนลักษณะเด่น ๆ อื่น ๆ ของการเขียนโปรแกรมเชิงอ็อบเจกต์ เช่น การกำหนดสาระสำคัญ (abstraction) การห่อหุ้ม (encapsulation) ภาวะพหุสัณฐาน
(polymorphism)  ผู้เขียนจึงขอเน้นเฉพาะลักษณะที่ภาษาไพทอนสนับสนุนเท่านั้น

[^token]: เนื่องจากคำในความหมายที่อ้างอิงตามมโนทัศน์ทางภาษาศาสตร์มีคำนิยามเฉพาะซึ่งไม่เหมือนกับโทเค็น 

```python
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 
```
บรรทัดแรก คือ การตั้งชื่อคลาส โดยการใช้คีย์เวิร์ด `class` ตามด้วยชื่อคลาส ชื่อคลาสมักจะใช้การสะกดแบบหลังอูฐ (camel case) ถ้าหากชื่อคลาสประกอบด้วยคำหลายคำ ให้ตัวอักษรแรกของแต่ละคำเป็นตัวใหญ่เช่น (`LanguageModel`, `AutoTokenizer`, `DefaultModelConfiguration`) จากนั้นให้ปิดด้วย `:`

บรรทัดต่อมา จะต้องเริ่มด้วยการเคาะย่อหน้าเพื่อบ่งบอกว่าโค้ดบล็อกที่อยู่ในย่อหน้านั้นเป็นของการกำหนดคลาส และจากนั้นก็เป็นการกำหนดลักษณะประจำคลาส (class attribute)ซึ่งจะเป็นการกำหนดตัวแปรที่คลาสนี้จำเป็นต้องมี  ในตัวอย่างนี้เรากำหนดลักษณะประจำของคลาส `Token` มีลักษณะประจำทั้งหมด 6 อย่าง คือ `word`, `pos`, `ner`, `lang`, `is_first`, `lemma` โดยเรากำหนดค่าเริ่มต้นให้กับลักษณะประจำทั้งหมด โดยใช้เครื่องหมาย `=` คล้ายคลึงกับการกำหนดค่าตัวแปร 

คลาส เป็นเพียงแค่ต้นแบบ หรือแบบแปลนให้ทราบว่าหนึ่งโทเคนนั้นจะต้องประกอบไปด้วยตัวแปรย่อย ๆ ซึ่งก็คือลักษณะประจำคลาส เมื่อเราต้องการนำคลาสนี้ไปใช้เก็บข้อมูล จะต้องมีการสร้างอ็อบเจกต์ (object) ของคลาสนี้ กระบวนการนี้เรียกว่า การสร้างกรณีตัวอย่าง (instantiation) ในภาษาไพทอนมีวิธีการสร้างอ็อบเจกต์โดยการใช้ชื่อคลาสตามด้วย `()` เช่น

```python
first_word = Token()
second_word = Token()
```
เราได้สร้างอ็อบเจกต์ของคลาสเก็บใส่ตัวแปร `first_word` และ `second_word` ในการกระบวนการนี้เราได้สร้างตัวแปรย่อย 6 ตัวเก็บไว้ใน `first_word` และตัวแปรย่อยอีก 6 ตัวเก็บไว้ใน `second_word` เป็นตัวแปรสองชุดแยกจากกันโดยสิ้นเชิง

ถ้าหากเราต้องการเข้าถึงหรือกำหนดค่าใหม่ให้ตัวแปรที่อยู่ในอ็อบเจกต์ ให้ใช้ `.`ตามด้วยชื่อของตัวแปร
```python 
first_word.word = 'Apple'
first_word.pos = 'NNP'
first_word.ner = 'ORG'
first_word.lang = 'en'
first_word.is_first = True
first_word.lemma = 'apple'

second_word.word = 'Inc.'
second_word.pos = 'NNP'
second_word.ner = 'ORG'
second_word.lang = 'en'
second_word.is_first = False
second_word.lemma = 'inc.'
```
จะเห็นได้ว่าการใช้คลาสที่สร้างขึ้นมาพิเศษในการเก็บข้อมูลแทนที่ดิกชันนารีมีข้อได้เปรียบหลายอย่าง อย่างแรกคือรับประกันได้ว่า `first_word` และ `second_word` มีจำนวนข้อมูลเท่ากันเพราะว่าเป็นอ็อบเจกต์ที่สร้างมาจากคลาสเดียวกัน และชื่อของตัวแปรย่อยที่อยู่ในอ็อบเจกต์เหล่านี้ก็ต้องเหมือนกัน และตัวแปรเหล่านั้นควรจะเก็บข้อมูลอย่างเดียวกันอยู่ อย่างที่สองคือการใช้ `.` เพื่อเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์สะดวกกว่าการใช้ `[]` เพื่อเข้าถึงข้อมูลที่อยู่ในดิกชันนารี เช่น
```python
first_word['word']
first_word.word
```
อย่างที่สามคือ หากเราใช้ IDE ที่ดี ๆ อย่าง PyCharm หรือ Visual Studio Code หรือปัญญาประดิษฐ์ที่ช่วยในการเขียนโค้ด เช่น GitHub Copilot เครื่องมือเหล่านี้จะช่วยเติมโค้ดให้สมบูรณ์โดยอัตโนมัติได้ เพราะว่าการกำหนดคลาสเป็นส่วนหนึ่งของโค้ดที่ IDE ได้ทำความเข้าใจแล้ว เช่น หากเราพิมพ์ `first_word.w` และ IDE สแกนและทำความเข้าใจเรียบร้อยแล้วว่า `first_word` มาจากคลาส `Token` ซึ่งมีลักษณะประจำชื่อว่า `word` ซึ่งเป็นตัวแแปรเดียวที่ขึ้นต้นด้วย w IDE จึงมีความสามารถที่จะเติมโค้ดให้เราเป็น `first_word.word` โดยอัตโนมัติ 

นอกจากนั้นแล้วหากเราห่างจากโค้ดก้อนนี้ไปนาน ๆ แล้วต้องกลับมาเขียนโค้ดเพิ่ม หรือต้องร่วมงานกับคนอื่นที่ต้องใช้โค้ดร่วมกับเรา เราก็สามารถอ้างอิงไปยังโค้ดที่กำหนดคลาส เพื่อทำความเข้าใจว่าคลาสที่เห็นอยู่เก็บข้อมูลอะไรอยู่บ้าง ซึ่งต่างจากดิกชันนารีที่ไม่มีโค้ดที่กำหนดคีย์ทั้งหมดของดิกชันนารีอย่างเป็นหลักเป็นแหล่งใช้อ้างอิงได้ 

ภาษาโปรแกรมที่เป็นภาษาเชิงอ็อบเจกต์ที่เก่าแก่กว่าภาษาไพทอน เช่น จาวา (Java) หรือ ซีพลัสพลัส(C++) จะมีการแบ่งแยกระดับการเข้าถึงตัวแปรชัดเจนว่าคลาสอื่น ๆ สามารถเข้าถึงแปรที่อยู่ในอ็อบเจกต์นี้ได้หรือไม่ (เช่น การใช้คีย์เวิร์ด `public` `private`และ `protected`) แต่ภาษาไพทอนตัวพื้นแบบที่ไม่ได้ใช้ไลบรารีตัวอื่น ๆ ช่วย ไม่ได้มีการแบ่งแยกระดับการเข้าถึง ทุกคลาส ทุกโปรแกรมสามารถเข้าถึงตัวแปรในอ็อบเจกต์และในคลาสได้ นักเขียนโปรแกรมบางกลุ่มแนะนำว่าให้ใส่ `_` ไปข้างหน้าชื่อตัวแปรเพื่อเป็นการบ่งบอกว่าโปรแกรมอื่น ๆ คลาสอื่น ๆ ไม่ควรจะเข้าถึงตัวแปรตัวนี้โดยตรง แต่ว่าภาษาไพทอนไม่มีการบังคับใช้กฎนี้แต่อย่างใด อย่างมากที่สุด คือ IDE อาจจะมีการเตือนผู้เขียนโปรแกรมอยู่บ้าง

## เมท็อด (method)
ก่อนถึงบทนี้เราได้มีการใช้เมท็อดโดยการใช้ `.` มาหลายครั้งแล้ว เพราะว่าทั้งสตริง ทั้งลิสต์ ทั้งดิกชันนารีต่างก็เป็นอ็อบเจกต์ทั้งหมด และเมท็อดเป็นโค้ดที่ใช้ประมวลผลข้อมูลที่อยู่ในอ็อบเจกต์ เพราะฉะนั้นเราจึงถือได้ว่า เมท็อดเป็นฟังก์ชันที่เป็นลักษณะเฉพาะเจาะจงของคลาส เช่น ลิสต์มีเมท็อดที่ชื่อว่า `append` และ `pop` ซึ่งเป็นเมท็อดที่ใช้ในการปฏิสัมพันธ์กับข้อมูลที่อยู่ในอ็อบเจกต์ที่เป็นลิสต์ 

### เมท็อดของคลาส

ในการกำหนดคลาส เราสามารถกำหนดเมท็อดให้คลาสได้ด้วย โดยการใช้คีย์เวิร์ด `def` ตามด้วยชื่อเมท็อด `()` และ `:` และอาร์กิวเมนต์แรกจะต้องเป็นคีย์เวิร์ด `self` ตัวอย่างเช่น
```python 
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def to_plural_form(self):
        if self.pos[0] == 'N':
            self.word = self.word + 's'
```
`self` คืออะไร และทำไมต้องใช้ `self` ในการกำหนดเมท็อด ในภาษาไพทอน การใช้ `self` ในการกำหนดเมท็อดเป็นการบอกว่าเมท็อดนี้เป็นเมท็อดของคลาส และเมท็อดนี้จะใช้ตัวแปร `self` เข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์ซึ่งก็คือตัวแปร (ลักษณะประจำ) ทั้งหมด ในตัวอย่างนี้เมท็อด `to_plural_form` ใช้ `self` เข้าถึงตัวแปร `pos` และ `word` และเปลี่ยนค่าของ `word` ให้เป็นรูปพหุสัณฐานของ `word` ถ้าหาก `pos` ของคำนั้นเป็น N ซึ่งหมายถึงคำนั้นเป็นนาม และเมท็อดนี้จะเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้ ซึ่งเป็นการเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้เท่านั้น ไม่ได้เปลี่ยนค่าของ `word` ในอ็อบเจกต์อื่น ๆ ที่เก็บอยู่ในตัวแปรอื่น ๆ 

ตัวอย่างการใช้เมท็อด `to_plural_form` ในการเปลี่ยนคำว่า `firm` ให้เป็น `firms` แสดงในโค้ดด้านล่าง
```python
word = Token()
word.word = 'firm'
word.pos = 'NN'
word.ner = 'O'
word.lang = 'en'
word.is_first = False
word.lemma = 'firm'

word.to_plural_form()
print(word.word) # firms
```
สังเกตว่าเวลาเรียกใช้เมท็อด `.to_plural_form` เราไม่ต้องใส่ `self` ลงไป เวลาเราเรียกใช้เมท็อด ไพทอนทราบเองโดยอัตโนมัติว่าเป็นการใช้เมท็อดของอ็อบเจกต์ที่อยู่ใน `word`  และจะส่งอ็อบเจกต์ที่เรียกเมท็อดนี้เข้าไปในอาร์กิวเมนต์แรกของเมท็อด ซึ่งเป็นเหตุผลที่ทำให้เราไม่ต้องใส่ `self` ลงไปในอาร์กิวเมนต์ของเมท็อดอีก 

### ตัวสร้าง (Constructor)
ตัวสร้าง (constructor) คือเมท็อดที่ถูกเรียกทำงานทันทีที่อ็อบเจกต์ถูกสร้างขึ้นมาากคลาสโดยการเรียกชื่อคลาสตามด้วย `()` ในภาษาไพทอน เมท็อดตัวสร้างจะต้องมีชื่อเป็น `__init__` ไม่สามารถเป็นชื่ออื่นได้ แต่ว่าเราสามารถกำหนดอาร์กิวเมนต์เองได้ ตัวอย่างเช่น
```python
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def __init__(self, word):
        self.word = word
        self.lang = detect_lang(word)

```
ในตัวอย่างด้านบนเรากำหนดเมท็อดตัวสร้างที่จำเป็นต้องใส่อาร์กิวเมนต์หนึ่งตัว นั่นก็คือรูปของคำ และเมท็อดนี้จะกำหนดค่าให้ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้ ให้สังเกตว่า `word` ใน `__init__` อ้างถึงค่าที่ผู้ใช้โปรแกรมป้อนเข้ามา แต่ว่า `self.word` อ้างถึงตัวแปรที่อยู่ในอ็อบเจกต์ที่เรียกเมท็อดตัวสร้างนี้ กล่าวคือเราได้สร้างตัวแปรทั้งหมดที่อยู่ในคลาส `Token` เรียบร้อยแล้วได้แก่ `word`, `pos`, `ner`, `lang`, `is_first`, `lemma` เราจึงอ้างถึงตัวแปร `self.word`  จากนั้นตัวสร้างจึงเรียกฟังก์ชัน `detect_lang` (คิดไปก่อนว่าเรามีฟังก์ชันนี้ที่สามารถรับสตริงและคืนค่ารหัสภาษา) เพื่อหาภาษาของคำนั้น ๆ และกำหนดค่าให้ `lang` ซึ่งเป็นตัวแปรในอ็อบเจกต์ที่เรียกเมท็อดนี้ 

เนื่องจาก `word` นั้นมีการถูกกำหนดค่าในตัวสร้างอยู่แล้วบางครั้ง เราอาจจะไม่กำหนดตัวแปรไว้ล่วงหน้านอกตัวสร้าง โค้ดอาจจะปรับเป็นดังตัวอย่างข้างล่าง โดยที่ไม่กระทบต่อการนำไปใช้จริง
```python
class Token:
    # ตัดเอา word ออกไป
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def __init__(self, word):
        self.word = word
        self.lang = detect_lang(word)
```

ตัวอย่างการใช้เมท็อดตัวสร้างแสดงในโค้ดด้านล่าง
```python
my_token = Token('firm')
print(my_token.lang) # en
```
สังเกตว่าเวลาเราสร้างอ็อบเจกต์ของคลาส `Token` เราใส่อาร์กิวเมนต์ 1 ตัวเพื่อส่งให้กับเมท็อดตัวสร้าง ไม่ใช่สองตัว (`self` และ `word`) 

ในทำนองเดียวกันกับตัวแปรประจำคลาส เมท็อดในภาษาไพทอนไม่มีการแบ่งแยกระดับการเข้าถึง ทุกคลาส ทุกโปรแกรมสามารถเรียกใช้เมท็อดของคลาสอื่น ๆ ได้ และเมท็อดที่เรากำหนดขึ้นมาเองก็สามารถเรียกใช้เมท็อดของคลาสอื่น ๆ ได้เช่นกัน 

## สิ่งสืบทอด (inheritance)
ตอนนี้ทุกคนอาจจะยังไม่ได้เห็นประโยชน์ของการเขียนโปรแกรมเชิงอ็อบเจกต์เท่าไรนัก เพราะว่าเราสามารถใช้ดิกชันนารีแทนคลาสได้ และเขียนโปรแกรมอย่างระมัดระวังไม่ให้เกิดการเข้าถึงข้อมูลผ่านคีย์ที่ไม่ได้มีอยู่ในดิกชันนารี และเราสามารถเขียนฟังก์ชันแทนการเขียนเมท็อดได้ ถ้าหากเราจัดระเบียบโค้ดดี ๆ ก็ทำให้เราหลีกเลี่ยงของผิดพลาดในการเขียนโปรแกรมได้ 

การใช้สิ่งสืบทอด (inheritance) เป็นรูปแบบการใช้งาน (feature) ที่ทำให้การเขียนโปรแกรมเชิงอ็อบเจกต์ดูน่าดึงดูดใจมากขึ้น สิ่งสืบทอดเป็นการสืบทอดลักษณะประจำและเมท็อดจากคลาสหนึ่งไปยังอีกคลาสหนึ่ง  ซึ่งทำให้เราสามารถใช้โค้ดที่เขียนไว้แล้วมาใช้ใหม่ได้ คลาสที่เป็นซับคลาส (subclass) สืบทอดเอาลักษณะประจำ (ตัวแปร) และเมท็อด (ฟังก์ชัน) จากคลาสที่เป็นซูเปอร์คลาส (superclass) และซับคลาสสามารถลบล้าง (override) เมท็อดที่สืบทอดมาให้เป็นไปตามต้องการได้ด้วย 

ตัวอย่าง เช่น คลาสที่ชื่อว่าเคาน์เตอร์ (`Counter`) ที่มากับไพทอน เป็นซับคลาสของคลาสที่ชื่อว่าดิกชันนารี (`dict`) หมายความว่าเคาน์เตอร์มีตัวแปรและเมท็อดของดิกชันนารีทั้งหมด แต่สามารถปรับแก้เมท็อดที่สืบทอดมา และเพิ่มเมท็อดอื่น ๆ เพิ่มเติมเข้าไปได้อีกด้วย เพราะฉะนั้นเราคิดไปก่อนได้เลยว่า `Counter` จะต้องมีเมท็อด `items` `keys` `values` `update` `clear` ฯลฯ นอกจากนั้นแล้วเนื่องจาก `Counter` เป็นซับคลาสจึงมีเมท็อดพิเศษเพิ่มเข้ามาอย่าง `most_common` 

การกำหนดให้ `Counter` เป็นซับคลาสของ `dict` มีข้อดีคือ ทำให้ `Counter` ใช้กลไกในการเก็บข้อมูลในลักษณะประจำ และกลไกการเข้าถึงข้อมูลได้เหมือน `dict` ทุกประการ โดยที่ไม่ต้องคัดลอกโค้ดของ `dict` มาทั้งหมด และยังสามารถปรับแก้เมท็อดที่สืบทอดมาได้อีกด้วย เช่น ลบล้างตัวสร้างที่สืบทอดมาเพื่อเปลี่ยนให้ตัวสร้างให้สามารถสร้างจากลิสต์ได้ ลบล้างเมท็อดการค้นหาแวลูจากคีย์เพื่อเปลี่ยนให้คืนค่าเป็น 0 ถ้าหากเรียกใช้คีย์ที่ไม่เคยปรากฏมาก่อน เป็นต้น 

การกำหนดคลาสให้เป็นซับคลาสของอีกคลาสหนึ่งสามารถทำได้ตอนที่เขียนโค้ดส่วนที่กำหนดคลาส โดยใช้คียเวิร์ด `class` ตามด้วยชื่อคลาสและใส่ชื่อซุปเปอร์คลาสในวงเล็บ ตามด้วย `:` เช่น
```python
class Counter(dict):
```
ไวยากรณ์สำหรับการกำหนดคลาสและซับคลาสคือ 
```python
class ชื่อซับคลาส(ชื่อซูเปอร์คลาส):
    ย่อหน้า
    ชื่อลักษณะประจำ
    ตัวสร้าง
    เมท็อด
```

ในมุมมองของผู้ใช้คลาส เมื่อผู้ใช้ทราบว่าคลาสที่ใช้เป็นซับคลาสของคลาสอะไร ผู้ใช้ก็จะทราบทันทีว่าคลาสที่ต้องการใช้มีไว้ทำอะไร มีเมท็อดอะไรบ้าง ยกตัวอย่างเช่น  `Counter` และ `dict` หากเราทราบแล้วว่าเคาน์เตอร์เป็นซับคลาสของดิกชันนารี เราสามารถคิดไปก่อนเลยได้ว่าเคาน์เตอร์มีความสามารถทำทุกสิ่งที่ดิกชันนารีสามารถทำได้ แต่ว่าหลังบ้านอาจมีความแตกต่างกัน เช่น ผู้ใช้คลาสเคาน์เตอร์ต้องรู้เพียงแต่ว่าเคาน์เตอร์มีแวลูเป็นตัวเลขเท่านั้น และคีย์ที่ไม่ได้ปรากฏในเคาน์เตอร์จะมีแวลูเป็น 0 เสมอ 

ในมุมมองของนักเขียนโปรแกรม การใช้สิ่งสืบทอดทำให้เราสามารถใช้โค้ดที่เขียนไว้แล้วมาใช้ใหม่ได้ และปรับแก้เฉพาะส่วนที่ต้องการเท่านั้น 

## ตัวอย่างการใช้สิ่งสืบทอด
การเปลี่ยนให้เป็นโทเค็น เป็นกระบวนการแรกในการประมวลผลภาษาธรรมชาติ คือการตัดสตริงของข้อมูลภาษาให้เป็นหน่วยที่ชื่อว่าโทเค็น ซึ่งแปลว่าหน่วยที่เหมาะในการประมวลผล โทเค็นส่วนใหญ่แล้วจะคล้ายคลึงกับคำเป็นส่วนใหญ่ โทเค็นจะเป็นอะไรนั้นขึ้นอยู่กับผู้ที่วิเคราะห์และประมวลผลข้อความที่จะปรับให้โทเค็นเป็นลักษณะอย่างไร 

ตัวอย่างเช่น หากเราต้องการสร้างตัวตัดคำภาษาไทย โดยการใช้รายการคำศัพท์ (vocab list) เป็นเกณฑ์ในการตัด และถ้าหากว่าเราได้รับประโยคที่เราเคยตัดคำมาแล้ว ให้คืนค่าเป็นผลลัพท์เดิม เพื่อความรวดเร็ว เราอาจจะออกแบบคลาส `ThaiTokenizer"` ขึ้นมาดังนี้

```python
class ThaiTokenizer:
    vocab_list = [x.strip() for x in open('thai-vocab.txt').readlines()
    ]
    cache = {}

    def __init__(self):
        pass

    def tokenize(self, sentence):
        if sentence in self.cache:
            return self.cache[sentence]
        
        segmented = segment(self.vocab_list, sentence)
        self.cache[sentence] = segmented
        return segmented
    
    def add_more_vocab(word_list):
        self.vocab_list.extend(word_list)
```
คลาสที่ชื่อว่า `ThaiTokenizer` มีลักษณะประจำทั้งหมด 2 ตัว คือ `vocab_list` และ `cache` และมีเมท็อดที่ชื่อว่า `tokenize` และ `add_more_vocab` โดย `tokenize` จะใช้ฟังก์ชันที่ชื่อว่า `segment` (ไม่ได้ให้โค้ดของฟังก์ชันนี้มา) ในการตัดคำ และ `add_more_vocab` จะใช้ในการเพิ่มคำศัพท์เข้าไปใน `vocab_list` และเมท็อดตัวสร้าง `__init__` จะไม่ทำอะไรเลย 

เมื่อผู้ใช้ต้องการตัดคำสามารถทำได้ดังนี้
```python
tokenizer = ThaiTokenizer()
print(tokenizer.tokenize('สวัสดีครับ')) # ['สวัสดี', 'ครับ']
```

สมมติว่าเราต้องการสร้างคลาสใหม่ที่มีความสามารถเพิ่มเติม คือสามารถตัดคำที่มีศัพท์ทางการแพทย์ เช่่น ชื่อโรค ชื่อยา อยู่ เพื่อนำไปใช้ประมวลผลเอกสารที่มาจากโรงพยาบาล เราสังเกตว่าคลาสใหม่ที่เราต้องการสร้างนั้นที่จริงจะต้องมีความสามารถทั้งหมดของ `ThaiTokenizer` เพียงแต่ว่าต้องมีคำศัพท์เพิ่มเติมใน `vocab_list` เมื่อสังเกตได้ดังนี้ เราควรจะเขียนให้คลาสใหม่นี้เป็นซับคลาสของ `ThaiTokenizer` ดังนี้
```python
class MedicalThaiTokenizer(ThaiTokenizer):

    def __init__(self, drug_name_list, disease_name_list):
        self.vocab_list.extend(drug_name_list)
        self.vocab_list.extend(disease_name_list)
        self.drug_name_list = drug_name_list
        self.disease_name_list = disease_name_list

    def contains_medical_terms(self, token_list):
        for token in token_list:
            if token in self.drug_name_list or token in self.disease_name_list:
                return True
        return False
```
ในตัวอย่างนี้เราทำการลบล้างเมท็อดตัวสร้างของ `ThaiTokenizer` ซึ่งสืบทอดมาจากซุปเปอร์คลาส โดยที่เมท็อดตัวสร้างของ `MedicalThaiTokenizer` จะบังคับให้ผู้ใช้ระบุคำศัพท์ที่เป็นชื่อยา และชื่อโรคเพิ่มเติม ก่อนที่ตัวสร้างจะเพิ่มเข้าไปใน `vocab_list` และเพิ่มตัวแปรที่เป็นลักษณะประจำอีกสองตัว คือ `drug_name_list` และ `disease_name_list` นอกจากนั้นเรายังเพิ่มเมท็อดที่ชื่อว่า `contains_medical_terms` ซึ่งจะใช้ในการตรวจสอบว่าประโยคที่เราต้องการตัดคำมีคำที่เป็นชื่อยาหรือชื่อโรคหรือไม่

เมื่อผู้ใช้ต้องการใช้คลาสใหม่นี้สามารถทำได้ดังนี้
```python
tokenizer = MedicalThaiTokenizer(['เพนนิซิลิน', 'แอสไพริน', 'ไวโคดิน'], ['เล็บโตสไปโรสิส', 'ไมเกรน'])
print(tokenizer.tokenize('เพนนิซิลินเป็นยาที่ใช้ในการรักษาโรคเบาหวาน')) # ['เพนนิซิลิน', 'เป็น', 'ยา', 'ที่', 'ใช้', 'ใน', 'การ', 'รักษา', 'โรค', 'เบาหวาน']
```
สังเกตว่าในโค้ดที่กำหนดคลาสเราไม่ได้เขียนเลยว่ามีเมท็อดที่ชื่อว่า `tokenize` เนื่องจาก `MedicalThaiTokenizer` เป็นซับคลาสของ `ThaiTokenizer` และ `ThaiTokenizer` มีเมท็อดที่ชื่อว่า `tokenize` อยู่แล้ว จึงได้รับการสืบทอดลงมาถึง `MedicalThaiTokenizer` ด้วย

ถึงแม้สิ่งสืบทอดทำให้สะดวกในการจัดระเบียบและนำโค้ดเก่ามาใช้เป็นระบบ ข้อเสียคือทำให้โค้ดทั้งหมดไม่ได้อยู่ในที่เดียวกัน เช่น ในกรณีข้างต้น ถ้าหากเราต้องการทราบว่า `MedicalThaiTokenizer` มีเมท็อดอะไรบ้าง เราต้องไปเปิดโค้ดของซุปเปอร์คลาส `ThaiTokenizer` ทำให้โค้ดกระจัดกระจาย ยากต่อการทำความเข้าใจในบางครั้ง โดยเฉพาะอย่างยิ่งถ้าหากเราไม่ระมัดระวังและทำให้ตระกูลของคลาสมีความซับซ้อนเกินไป เช่น `LegalMedicalThaiTokenizer` เป็นซับคลาสของ `MedicalThaiTokenizer` ซึ่งเป็นซับคลาสของ `ThaiTokenizer` อีกครั้งหนึ่ง เพราะฉะนั้นบางเมท็อดของ `LegalMedicalThaiTokenizer` อาจจะมาจาก 


## สรุป
ผู้เขียนโปรแกรมต้องตัดสินใจออกแบบว่า OOP นั้นเหมาะสมกับโจทย์หรือไม่ เพราะไพทอน ไม่ได้บังคับให้ใช้ OOP ในทุกสถานการณ์แต่ก็มีคุณสมบัติหลักๆ ของ OOP อยู่ ข้อดีของการใช้ OOP คือช่วยให้โค้ดมีความสะอาด และง่ายต่อการอ่าน การแบ่งโปรแกรมเป็นส่วนย่อย ๆ ช่วยให้สามารถจัดการกับความซับซ้อนของโปรแกรมได้ดีขึ้น นอกจากนี้ยังช่วยในเรื่องของการนำโค้ดไปใช้ซ้ำ และการปรับเปลี่ยนโค้ดในอนาคตได้ง่ายขึ้น เพราะการแก้ไขหรือต่อเติมเมท็อดในคลาสหนึ่ง ๆ ไม่จำเป็นต้องกระทบกับส่วนอื่น ๆ ของโปรแกรม 

อย่างไรก็ตาม ข้อเสียของการใช้ OOP คืออาจทำให้โค้ดมีความซับซ้อนเกินความจำเป็นในบางสถานการณ์ การออกแบบที่ไม่ดีอาจนำไปสู่โค้ดที่ยุ่งเหยิง และการอ้างอิงที่ซับซ้อน ซึ่งสามารถทำให้การบำรุงรักษาโค้ดเป็นเรื่องยาก

การตัดสินใจใช้ OOP ในภาษาไพทอน ควรขึ้นอยู่กับลักษณะของโปรเจกต์และทีมพัฒนา หากโปรเจกต์ต้องอาศัยความยืดหยุ่นในการจัดการกับออบเจกต์และข้อมูล หรือต้องการทำงานร่วมกับโค้ดที่มีอยู่แล้วซึ่งออกแบบมาในแบบ OOP การใช้แนวทางนี้อาจเป็นทางเลือกที่ดี แต่สำหรับโปรเจกต์ที่เรียบง่ายหรือทีมที่ไม่คุ้นเคยกับ OOP อาจพิจารณาใช้วิธีการเขียนโปรแกรมแบบอื่นที่ไพทอนรองรับได้เช่นกัน 