# บทที่ 6 </br> การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming)
<!--บทนี้ใส่ margin คำศัพท์ยาก เพราะเนื้อหาอยู่ติดกัน ไม่ได้กล่าวถึงโดยรวมเหมือนบทแรก จำเป็นต้องมี margin คำศัพท์มั้ย

สำหรับ margin เปล่าสามารถนำเกร็ดความรู้พวกธรรมเนียมการเขียนโค้ดไปย่อใส่แบบสั้นได้ หลังอธิบายเสร็จ ต้องการหรือไม่ต้องการยังไงก็บอกหน่อยนะคะ จะได้ไปตามเติม เช่น def __innit__ ต้องอยู่ตามหลังลักษณะพิเศษ และอยู่ก่อนเมท็อดอื่น -->

```{admonition} จุดมุ่งหมายของบทนี้
- ผู้อ่านรู้ว่ารูปแบบการเขียนโปรแกรมเชิงอ็อบเจกต์นั้นเป็นอย่างไร
- ผู้อ่านเข้าใจและสามารถอธิบายความแตกต่างของ `class` `object` `attribute` `method` `constructor` และ `inheritance` ได้
- ผู้อ่านสามารถเขียนโปรแกรมที่มีลักษณะเชิงอ็อบเจกต์ได้
- ผู้อ่านสามารถอ่านโค้ดที่มีการใช้รูปแบบการเขียนโปรแกรมเชิงอ็อบเจกต์ และสามารถเรียกใช้คำสั่งได้ตามต้องการ

```
สมมติว่าผู้เขียนโปรแกรมต้องการเก็บข้อมูลของคำแต่ละคำที่อยู่ในย่อหน้าย่อหน้าหนึ่ง  โครงสร้างข้อมูลที่เหมาะสมที่สุดกับข้อมูลประเภทนี้ คือ การใช้ลิสต์เก็บสตริง เช่น
```python
paragraph = ['Apple', 'Inc.' 'is' 'an' 'American' 'multinational' 'technology' 'firm'  'headquartered', 'in' 'Cupertino', 'California' '.']
```
แต่หากว่าผู้เขียนโปรแกรมจำต้องเก็บข้อมูลของคำแต่ละคำละเอียดขึ้น เช่น ชนิดของคำ (part-of-speech) ประเภทของชื่อเฉพาะ (named entity) คำนี้เป็นภาษาอะไร คำนี้เป็นคำที่ขึ้นต้นประโยคหรือไม่ คำนี้มีรูปปกติ (lemma) หรือรูปก่อนการผันรูปเป็นอะไร โครงสร้างข้อมูลที่เหมาะสมสำหรับการเก็บข้อมูลประเภทนี้ก็จะเปลี่ยนเป็น ลิสต์ของดิกชันนารี ที่มีลักษณะดังนี้
```python
[
    {"word": "Apple",
    "pos": "NNP",
    "ner": "ORG",
    "lang": "en",
    "is_first": True,
    "lemma": "apple" },
    {"word": "Inc.",
    "pos": "NNP",
    "ner": "ORG",
    "lang": "en",
    "is_first": False,
    "lemma": "inc."},
    {"word": "is",
    "pos": "VBZ",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "be"},
    {"word": "an",
    "pos": "DT",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "an"},
    {"word": "American",
    "pos": "JJ",
    "ner": "MISC",
    "lang": "en",
    "is_first": False,
    "lemma": "american"},
    {"word": "multinational",
    "pos": "JJ",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "multinational"},
    {"word": "technology",
    "pos": "NN",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "technology"},
    {"word": "firm",
    "pos": "NN",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "firm"},
    {"word": "headquartered",
    "pos": "VBN",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "headquarter"},
    {"word": "in",
    "pos": "IN",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "in"},
    {"word": "Cupertino",
    "pos": "NNP",
    "ner": "LOC",
    "lang": "en",
    "is_first": False,
    "lemma": "cupertino"},
    {"word": "California",
    "pos": "NNP",
    "ner": "LOC",
    "lang": "en",
    "is_first": False,
    "lemma": "california"},
    {"word": ".",
    "pos": ".",
    "ner": "O",
    "lang": "en",
    "is_first": False,
    "lemma": "."}
]

```
<!--แก้จาก ฟีลด์ เป็น คีย์ ถ้าไม่แก้ต้องเติมความหมายคำว่าฟีลด์ เพราะไม่ได้กล่าวมาก่อนในบทก่อนหน้า-->
จะสังเกตได้ว่า ดิกชันนารีเบื้องต้นนี้ประกอบไปด้วยข้อมูลกว่า 6 คีย์ ซึ่งในการเขียนโปรแกรมขึ้นมาเพื่อประมวลผลข้อมูลดังกล่าว ผู้เขียนโปรแกรมจำเป็นต้องระวังว่าดิกชันนารีที่เก็บข้อมูลของคำแต่ละคำนั้นจะต้องประกอบไปด้วยทั้ง 6 คีย์ครบถ้วนเช่นเดิม และต้องทราบด้วยว่าประกอบไปด้วยคีย์และแวลูประเภทใดบ้าง เพื่อให้สามารถเขียนฟังก์ชันที่เข้าถึงและประมวลผลข้อมูลได้อย่างถูกต้อง

อย่างไรก็ตาม หากมีการเปลี่ยนชื่อคีย์หรือเพิ่มคีย์ใหม่ในดิกชันนารี ฟังก์ชันที่พัฒนาไว้เดิมก็ต้องถูกแก้ไขใหม่ทั้งหมด ซึ่งอาจก่อให้เกิดข้อผิดพลาด และทำให้การบำรุงรักษาโปรแกรมทำได้ยาก โดยเฉพาะอย่างยิ่งในกรณีที่โค้ดที่ใช้สร้างดิกชันนารีและโค้ดที่ประมวลผลข้อมูลนั้นอยู่กันคนละไฟล์ 

ทั้งนี้ เพื่อเป็นการเลี่ยงปัญหาดังกล่าว รวมถึงทำให้การแก้ไข และบำรุงรักษาโค้ดนั้นสามารถดำเนินไปได้โดยสะดวก ผู้เขียนโปรแกรมจึงได้มีการนำแนวคิดการเขียนโปรแกรมเชิงอ็อบเจ็กต์ (Object-Oriented Programming: OOP) มาใช้ในการเขียนโปรแกรม
<!--เพิ่มเรื่องความสำคัญมา แต่อาจขยายความความสำคัญเพิ่มเติมได้ ว่ามีความสำคัญอื่นมั้ย และทำไมในปัจจุบันถึงไม่นิยมใช้แล้ว-->
การพัฒนาโปรแกรมในอดีต มักมีการนำแนวทางการเขียนโปรแกรมเชิงอ็อบเจ็กต์มาใช้กันอย่างแพร่หลาย ผู้เรียนและผู้เขียนโปรแกรมจึงอาจต้องเผชิญกับสถานการณ์ที่จำเป็นต้องนำโค้ดเหล่านี้มาใช้งานต่อ หรือเข้าไปแก้ไขเพิ่มเติม การเข้าใจแนวคิดของการเขียนโปรแกรมเชิงอ็อบเจ็กต์จึงเป็นอีกหนึ่งพื้นฐานสำคัญในการเรียนการเขียนโปรแกรมและการประมวลผลภาษาธรรมชาติ

## คลาส (class) และอ็อบเจกต์ (object)

<!--หัวข้อย่อยชื่อ class and objects แต่ไม่ได้มีการกล่าวถึง object เนื้อหาข้อง class และ objects จริงๆไปอยู่ใน #attributes อาจเปลี่ยนชื่อข้อนี้เป็น 

#คุณลักษณะของการเขียนโปรแกรมเชิงอ็อบเจกต์ที่พบในไพธอน

แล้วเติมเนื้อหา หรือไม่ก็เอาข้อนี้ออก เอาเนื้อหาไปต่อกับเกริ่นนำ-->

<!-- change ::
ลักษณะเด่นของการเขียนโปรแกรมเชิงอ็อบเจกต์นั้นประกอบไปด้วยลักษณะเช่น การกำหนดสาระสำคัญ (abstraction) การห่อหุ้ม (encapsulation) ภาวะพหุสัณฐาน
(polymorphism) การควบคุมการเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์ เป็นต้น 
แต่ทั้งนี้ ภาษาไพทอนนั้นไม่ได้รองรับลักษณะเด่นทุกประการของการเขียนโปรแกรมเชิงอ็อบเจกต์ ในบทนี้จึงจะกล่าวถึงเพียงคุณลักษณะที่ภาษาไพทอนรองรับเท่านั้น 
คลาสในภาษาไพทอนประกอบลักษณะพิเศษหลัก ๆ 3 ประการ ได้แก่

1. ลักษณะประจำ (attribute) คือ ตัวแปรที่ใช้ในการเก็บข้อมูลภายในคลาส
2. เมท็อด (method) คือ ฟังก์ชันหรือโค้ดที่ใช้ประมวลผลหรือจัดการลักษณะประจำของคลาส 
3. สิ่งสืบทอด (inheritance) คือ กลไกที่ใช้ในการดึงเอาเมท็อดจากคลาสอื่นมาใช้ 
-->

การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming: OOP) คือหลักการที่ผู้เขียนโปรแกรมสามารถนำมาใช้ในการออกแบบโครงสร้างข้อมูลเพื่อให้สะดวกกับกรณีการใช้งานดังตัวอย่างในเกริ่นนำ 

หลักการของการเขียนโปรแกรมเชิงอ็อบเจกต์ คือ การออกแบบโครงสร้างข้อมูลขึ้นมาเป็นพิเศษ เฉพาะเจาะจงกับข้อมูลที่ต้องการจะเก็บ โครงสร้างข้อมูลนี้เรียกว่าคลาส (class) 


ลักษณะเด่นของการเขียนโปรแกรมเชิงอ็อบเจกต์นั้นประกอบไปด้วยลักษณะเช่น การกำหนดสาระสำคัญ (abstraction) การห่อหุ้ม (encapsulation) ภาวะพหุสัณฐาน
(polymorphism) การควบคุมการเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์ เป็นต้น 
แต่ทั้งนี้ ภาษาไพทอนนั้นไม่ได้รองรับลักษณะเด่นทุกประการของการเขียนโปรแกรมเชิงอ็อบเจกต์ ในบทนี้จึงจะกล่าวถึงเพียงคุณลักษณะที่ภาษาไพทอนรองรับเท่านั้น 
คลาสในภาษาไพทอนประกอบลักษณะพิเศษหลัก ๆ 3 ประการ ได้แก่

1. ลักษณะประจำ (attribute) คือ ตัวแปรที่ใช้ในการเก็บข้อมูลภายในคลาส
2. เมท็อด (method) คือ ฟังก์ชันหรือโค้ดที่ใช้ประมวลผลหรือจัดการลักษณะประจำของคลาส 
3. สิ่งสืบทอด (inheritance) คือ กลไกที่ใช้ในการดึงเอาเมท็อดจากคลาสอื่นมาใช้ 


## ลักษณะประจำ (attribute)

<!--อาจเปลี่ยนชื่อเป็น

# คลาส (class) อ็อบเจกต์ (object) และลักษณะประจำ (attribute) -->

<!-- change:

การเขียนโปรแกรมเชิงอ็อบเจกต์ (Object-Oriented Programming: OOP) คือหลักการที่ผู้เขียนโปรแกรมสามารถนำมาใช้ในการออกแบบโครงสร้างข้อมูลเพื่อให้สะดวกกับกรณีการใช้งานดังตัวอย่างในเกริ่นนำ 

หลักการของการเขียนโปรแกรมเชิงอ็อบเจกต์ คือ การออกแบบโครงสร้างข้อมูลขึ้นมาเป็นพิเศษ เฉพาะเจาะจงกับข้อมูลที่ต้องการจะเก็บ โครงสร้างข้อมูลนี้เรียกว่าคลาส (class) 

-->
<!--อาจยกตัวอย่างย่อหน้านึงสั้นๆก่อนว่า class, obj, attr เป็นยังไง เช่น เปรียบเหมือน obj เป็นคำๆนึง แล้ว attr คือลักษณะของคำนั้น ๆ เช่น word, pos, ner, etc. แล้ว class คือเหมือนแม่พิมพ์ที่เป็นตัวกำหนดว่า obj นึงจะต้องมีลักษณะยังไง

แล้วตอนท้ายของ attr ก็รวบยอดอีกรอบ -->

ลักษณะประจำ (attribute) เป็นตัวแปรที่เก็บซ้อนอยู่ในคลาส ใช้เก็บข้อมูลคล้ายคลึงกับตัวแปร 

เพื่อให้เห็นภาพมากขึ้น ตัวอย่างต่อไปนี้จะแสดงการเขียนคลาสเพื่อใช้เก็บข้อมูลคำในประโยคแทนการใช้ดิกชันนารี ในที่นี้จะใช้คำว่าโทเค็น (token) แทนที่คำว่า *คำ* เนื่องจากหากอ้างอิงตามมโนทัศน์ทางภาษาศาสตร์แล้ว  *คำ* นั้นมีนิยามเฉพาะที่แตกต่างจากโทเค็น โดยโทเค็น หมายถึง หน่วยหนึ่งหน่วยที่ผู้วิเคราะห์ใช้เป็นหน่วยที่เล็กที่สุดในการประมวลผล ตัวอย่างโค้ดที่ใช้ในการกำหนดคลาสมีดังนี้

```python
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 
```

บรรทัดแรก คือ การตั้งชื่อคลาส โดยการใช้คีย์เวิร์ด `class` ตามด้วยชื่อคลาส ชื่อคลาสมักจะใช้การสะกดแบบหลังอูฐ (camel case) ถ้าหากชื่อคลาสประกอบด้วยคำหลายคำ ให้ตัวอักษรแรกของแต่ละคำเป็นตัวใหญ่เช่น (`LanguageModel`, `AutoTokenizer`, `DefaultModelConfiguration`) จากนั้นปิดท้ายด้วย `:`

บรรทัดต่อมา จะต้องเริ่มด้วยการเคาะย่อหน้าเพื่อบ่งบอกว่าโค้ดบล็อกที่อยู่ในย่อหน้านั้นเป็นของการกำหนดคลาส จากนั้นจึงเป็นการกำหนดลักษณะประจำคลาส (class attribute) ซึ่งจะเป็นการกำหนดตัวแปรที่คลาสนี้จำเป็นต้องมี  ในตัวอย่างนี้จะกำหนดให้คลาส `Token` มีลักษณะประจำทั้งหมด 6 อย่าง คือ `word`, `pos`, `ner`, `lang`, `is_first`, `lemma` โดยผู้เขียนโปรแกรมสามารถกำหนดค่าเริ่มต้นให้กับลักษณะประจำทั้งหมดได้ โดยใช้เครื่องหมาย `=` คล้ายคลึงกับการกำหนดค่าตัวแปร 

ตามธรรมเนียมปฏิบัติของการเขียนคลาส ผู้เขียนโปรแกรมมักจะนำลักษณะประจำคลาสทั้งหมดมาไว้ตามหลังชื่อคลาสเพื่อความเข้าใจตรงกัน และทำให้หาได้ง่าย แม้ว่าแท้จริงแล้วลักษณะประจำคลาสนั้นจะสามารถวางไว้ส่วนใดของคลาสก็ได้ก็ตาม

คลาส (class) เป็นเพียงต้นแบบ หรือแบบแปลนให้ทราบว่าหนึ่งโทเคนนั้นจะต้องประกอบไปด้วยตัวแปรย่อย ๆ ซึ่งก็คือลักษณะประจำคลาสดังนี้เท่านั้น เมื่อผู้เขียนโปรแกรมต้องการนำคลาสนี้ไปใช้เก็บข้อมูล จะต้องมีการสร้างอ็อบเจกต์ (object) ของคลาสนี้ขึ้นมา กระบวนการนี้เรียกว่า การสร้างกรณีตัวอย่าง (instantiation) 
ในภาษาไพทอนมีวิธีการสร้างอ็อบเจกต์โดยการใช้ชื่อคลาสตามด้วย `()` ดังนี้

```python
first_word = Token()
second_word = Token()
```
จากโค้ดเบื้องต้น ผู้เขียนโปรแกรมได้สร้างอ็อบเจกต์ของคลาสเก็บไว้ในตัวแปร `first_word` และ `second_word` ในการกระบวนการนี้ โค้ดดังกล่าวได้สร้างตัวแปรย่อย 6 ตัวเก็บไว้ใน `first_word` และตัวแปรย่อยอีก 6 ตัวเก็บไว้ใน `second_word` เป็นตัวแปรสองชุดแยกจากกันโดยสิ้นเชิง

ถ้าหากผู้เขียนโปรแกรมต้องการเข้าถึงหรือกำหนดค่าใหม่ให้กับตัวแปรที่อยู่ในอ็อบเจกต์ สามารถทำได้โดยการใช้ อ็อบเจกต์`.`ตามด้วยชื่อของตัวแปร
```python 
first_word.word = 'Apple'
first_word.pos = 'NNP'
first_word.ner = 'ORG'
first_word.lang = 'en'
first_word.is_first = True
first_word.lemma = 'apple'

second_word.word = 'Inc.'
second_word.pos = 'NNP'
second_word.ner = 'ORG'
second_word.lang = 'en'
second_word.is_first = False
second_word.lemma = 'inc.'
```
จะเห็นได้ว่าการใช้คลาสที่สร้างขึ้นมาพิเศษในการเก็บข้อมูลแทนที่ดิกชันนารีนั้นมีข้อได้เปรียบหลายประการ

ประการแรก คือ การสามารถประกันได้ว่า `first_word` และ `second_word` มีจำนวนข้อมูลเท่ากัน เพราะว่าเป็นอ็อบเจกต์ที่สร้างมาจากคลาสเดียวกัน ดังนั้นชื่อของตัวแปรย่อยที่อยู่ในอ็อบเจกต์เหล่านี้ก็ต้องเหมือนกัน และตัวแปรเหล่านั้นก็พึงเก็บข้อมูลอย่างเดียวกันอยู่ 

ประการที่สอง คือ การเข้าถึงข้อมูลที่ง่ายกว่า การใช้ `.` เพื่อเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์สะดวกกว่าการใช้ `[]` เพื่อเข้าถึงข้อมูลที่อยู่ในดิกชันนารี เนื่องจากลดการพิมพ์ลงไปได้ และอ่านได้สะดวกกว่า ดังตัวอย่าง

```python
first_word['word']
first_word.word
```

ประการที่สาม คือ ทำให้สามารถเขียนโค้ดได้สะดวกขึ้นเมื่อใช้บนโปรแกรมไอดีอี โปรแกรมไอดีอี (IDE: Integrated Development Environment หรือโปรแกรมที่มีเครื่องมือช่วยพัฒนาโปรแกรมแบบครบครัน) อย่าง VSCode หรือเครื่องมือปัญญาประดิษฐ์ที่ช่วยในการเขียนโค้ด เช่น GitHub Copilot สามารถช่วยเติมโค้ดให้สมบูรณ์โดยอัตโนมัติได้ เพราะว่าการกำหนดคลาสเป็นส่วนหนึ่งของโค้ดที่โปรแกรมไอดีอีได้ทำความเข้าใจแล้ว เช่น หากพิมพ์ `first_word.w` และไอดีอีสแกนและทำความเข้าใจเรียบร้อยแล้วว่า `first_word` มาจากคลาส `Token` ซึ่งมีลักษณะประจำชื่อว่า `word` ซึ่งเป็นตัวแแปรเดียวที่ขึ้นต้นด้วย w ไอดีอีจะสามารถเติมโค้ดให้เป็น `first_word.word` ได้โดยอัตโนมัติ 

ข้อได้เปรียบอีกประการหนึ่ง คือ หากผู้เขียนโปรแกรมนั้นไม่ได้ทำงานร่วมกับโค้ดหรือโปรแกรมดังกล่าวมาเป็นเวลานาน แล้วต้องกลับมาเขียนโค้ดเพิ่ม หรือต้องร่วมงานกับผู้อื่นที่ต้องใช้โค้ดร่วมกัน ผู้เขียนโปรแกรมก็สามารถอ้างอิงไปยังโค้ดส่วนที่กำหนดคลาส เพื่อทำความเข้าใจว่าอ็อบเจกต์ของคลาสที่เห็นอยู่นั้นเก็บข้อมูลอะไรไว้บ้าง ซึ่งต่างจากดิกชันนารีที่ไม่มีการกำหนดส่วนของโค้ดที่กำหนดคีย์ทั้งหมดของดิกชันนารีไว้อย่างเป็นทางการที่สามารถกลับไปอ้างอิงได้โดยง่าย จำต้องหาจากโค้ดทั้งหมดเอง

ภาษาโปรแกรมที่เป็นภาษาโปรแกรมเชิงอ็อบเจกต์ที่เก่าแก่กว่าภาษาไพทอน เช่น จาวา (Java) หรือ ซีพลัสพลัส (C++) จะมีการแบ่งแยกระดับการเข้าถึงตัวแปรชัดเจนว่าคลาสอื่น ๆ สามารถเข้าถึงตัวแปรที่อยู่ในอ็อบเจกต์นี้ได้หรือไม่ (เช่น การใช้คีย์เวิร์ด `public` `private` และ `protected`) แต่ภาษาไพทอนโดยพื้นฐานแบบที่ไม่ได้ใช้ไลบรารีตัวอื่น ๆ ช่วย ไม่ได้มีการแบ่งแยกระดับการเข้าถึง ทุกคลาส ทุกโปรแกรมสามารถเข้าถึงตัวแปรในอ็อบเจกต์และในคลาสได้ นักเขียนโปรแกรมบางกลุ่มจึงแนะนำว่าให้ใส่ `_` ไปข้างหน้าชื่อตัวแปรเพื่อเป็นการบ่งบอกว่าโปรแกรมอื่น ๆ คลาสอื่น ๆ ไม่ควรจะเข้าถึงตัวแปรตัวนี้โดยตรง แต่ทั้งนี้ ภาษาไพทอนไม่มีการบังคับใช้กฎนี้แต่อย่างใด อย่างมากที่สุด คือ ไอดีอี อาจจะมีการเตือนผู้เขียนโปรแกรมอยู่บ้าง
<!--เติมตัวอย่างว่าการใช้ผิดเป็นยังไง ให้ชัดว่าโค้ดจะยุ่งเหยิงยังไงเมื่อคลาสอื่นเรียกใช้โดยตรง-->
<!--change:
ยกตัวอย่างผลลัพธ์ที่อาจเกิดขึ้นได้หากคลาสอื่น ๆ นั้นเข้าถึงตัวแปรของคลาสได้โดยตรง คือโค้ดจะยึดกันมากไป หากมีการเปลี่ยนแปลงชื่อตัวแปรในอนาคตแล้ว ก็ต้องไปแก้ชื่อตัวแปรในส่วนของที่คลาสอื่นเรียกใช้โดยตรงด้วย ซึ่งเป็นการดำเนินการที่ยุ่งยาก และทำให้เสียคุณลักษณะการออกแบบโค้ดที่ดี โดยทั่วไปแล้ว ควรเรียกใช้ผ่านเมท็อด (method) ไม่ใช่ตัวแปรในอ็อบเจกต์โดยตรง
-->


## เมท็อด (method)

ก่อนถึงบทนี้ผู้เขียนโปรแกรมได้มีการเรียกใช้เมท็อดผ่านการใช้ `.` มาหลายครั้งแล้ว เพราะทั้งสตริง ลิสต์ และดิกชันนารี ที่ใช้ในการเก็บข้อมูลเพื่อเขียนโปรแกรมที่ผ่านมาต่างก็เป็นอ็อบเจกต์ทั้งหมด เมท็อดที่ผู้เขียนโปรแกรมได้ใช้ล้วนแต่เป็นฟังก์ชันที่ใช้ประมวลผลข้อมูลที่อยู่ในอ็อบเจกต์ เพราะฉะนั้นจึงถือได้ว่า เมท็อด (method) เป็นฟังก์ชันที่เป็นลักษณะเฉพาะเจาะจงของคลาส เช่น ลิสต์มีเมท็อดที่ชื่อว่า `append` และ `pop` ซึ่งเป็นเมท็อดที่ใช้ในการปฏิสัมพันธ์กับข้อมูลที่อยู่ในอ็อบเจกต์ที่เป็นลิสต์เท่านั้น สตริง ดิกชันนารี หรือเซตไม่มีเมท็อดเหล่านี้ เพราะว่าเป็นอ็อบเจกต์จากต่างคลาสกัน 

### เมท็อดของคลาส

ในการกำหนดคลาส ผู้เขียนโปรแกรมสามารถกำหนดเมท็อดให้คลาสได้ด้วย โดยการใช้คีย์เวิร์ด `def` ตามด้วยชื่อเมท็อด `()` และ `:` และอาร์กิวเมนต์แรกจะต้องเป็นคีย์เวิร์ด `self` ตัวอย่างเช่น

```python 
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def to_plural_form(self):
        if self.pos[0] == 'N':
            self.word = self.word + 's'
```

`self` คืออะไร และทำไมต้องใช้ `self` ในการกำหนดเมท็อด 

คำถามหนึ่งที่ผู้เรียนและผู้เขียนโปรแกรมอาจสงสัยคือ `self` คืออะไร และทำไมต้องใช้ `self` ในการกำหนดเมท็อด 
ในภาษาไพทอน การใช้ `self` ในการกำหนดเมท็อดเป็นการบอกว่าเมท็อดนี้เป็นเมท็อดของคลาส และเมท็อดนี้จะใช้ตัวแปร `self` ในเข้าถึงข้อมูลที่อยู่ในอ็อบเจกต์ซึ่งก็คือตัวแปร (ลักษณะประจำ) ทั้งหมด 

ในตัวอย่างเบื้องต้น `to_plural_form` ใช้ `self` เพื่อเข้าถึงตัวแปร `pos` และ `word` และเปลี่ยนค่าของ `word` ให้เป็นรูปพหุสัณฐานของ `word` ถ้าหาก `pos` ของคำนั้นเป็น N 

หมายถึงว่าหากคำนั้นเป็นคำนาม เมท็อดนี้จะเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้ คือการเปลี่ยนค่าของ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้เท่านั้น ไม่ได้เปลี่ยนค่าของ `word` ในอ็อบเจกต์อื่น ๆ ที่เก็บอยู่ในตัวแปรอื่น ๆ 

ตัวอย่างการใช้เมท็อด `to_plural_form` ในการเปลี่ยนคำว่า `firm` ให้เป็น `firms` แสดงในโค้ดต่อไปนี้
```python
word = Token()
word.word = 'firm'
word.pos = 'NN'
word.ner = 'O'
word.lang = 'en'
word.is_first = False
word.lemma = 'firm'

word.to_plural_form()
print(word.word) # firms
```

ทั้งนี้ เมื่อเรียกใช้เมท็อด `.to_plural_form` ผู้เขียนโปรแกรมไม่จำเป็นต้องใส่ `self` ลงไป เพราะเวลาเรียกใช้เมท็อด ไพทอนจะทราบเองโดยอัตโนมัติว่าเป็นการใช้เมท็อดของอ็อบเจกต์ที่อยู่ใน `word`  และจะส่งอ็อบเจกต์ที่เรียกเมท็อดนี้เข้าไปในอาร์กิวเมนต์แรกของเมท็อด ซึ่งเป็นเหตุผลที่ทำให้ผู้เขียนโปรแกรมไม่ต้องใส่ `self` ลงไปในอาร์กิวเมนต์ของเมท็อดอีก 



### ตัวสร้าง (Constructor)
ตัวสร้าง (constructor) คือชื่อเรียกเมท็อดในคลาสที่จะถูกเรียกให้ทำงานทันทีที่อ็อบเจกต์ถูกสร้างขึ้นมา เมื่อถูกเรียกชื่อคลาสตามด้วย ` ()` ในภาษาไพทอน เมท็อดตัวสร้างจะต้องมีชื่อเป็น `__init__` ไม่สามารถเป็นชื่ออื่นได้ แต่ว่าผู้เขียนโปรแกรมสามารถกำหนดอาร์กิวเมนต์เองได้ ตัวอย่างเช่น

```python
class Token:
    word = ''
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def __init__(self, word):
        self.word = word
        self.lang = detect_lang(word) #ฟังก์ชันสมมติที่รับสตริงและคืนค่าเป็นรหัสภาษา

    def to_plural_form(self):
        if self.pos[0] == 'N':
            self.word = self.word + 's'
```

ตามธรรมเนียมปฏิบัติของการเขียนตัวสร้าง เพื่อให้มีความเข้าใจตรงกัน โปรแกรมเมอร์มักจะวางตัวสร้างไว้ตามหลังลักษณะประจำของคลาส ก่อนหน้าเมท็อดอื่น ๆ ที่จะตามมา

ในตัวอย่างเบื้องต้น ผู้เขียนโปรแกรมกำหนดเมท็อดตัวสร้างให้จำเป็นต้องใส่อาร์กิวเมนต์หนึ่งตัว นั่นก็คือรูปของคำ และเมท็อดนี้จะกำหนดค่าให้ `word` ในอ็อบเจกต์ที่เรียกเมท็อดนี้ ให้สังเกตว่า `word` ใน `__init__` อ้างถึงค่าที่ผู้ใช้โปรแกรมป้อนเข้ามา แต่ว่า `self.word` อ้างถึงตัวแปรที่อยู่ในอ็อบเจกต์ที่เรียกเมท็อดตัวสร้างนี้ กล่าวคือผู้เขียนโปรแกรมได้สร้างตัวแปรทั้งหมดที่อยู่ในคลาส `Token` เรียบร้อยแล้วได้แก่ `word`, `pos`, `ner`, `lang`, `is_first`, `lemma` จึงอ้างถึงตัวแปร `self.word`  จากนั้นตัวสร้างจึงเรียกฟังก์ชัน `detect_lang` (ฟังก์ชันสมมติที่สามารถรับสตริงและคืนค่าเป็นรหัสภาษา) เพื่อหาภาษาของคำนั้น ๆ และกำหนดค่าให้ `lang` ซึ่งเป็นตัวแปรในอ็อบเจกต์ที่เรียกเมท็อดนี้ 

เนื่องจากตัวแปร `word` นั้นถูกกำหนดค่าในเมท็อดตัวสร้างอยู่แล้ว บางครั้งผู้เขียนโปรแกรมจึงอาจจะไม่กำหนดตัวแปรไว้ล่วงหน้านอกตัวสร้าง โค้ดอาจจะปรับเป็นดังตัวอย่างข้างล่าง ซึ่งการปรับนี้ไม่ได้กระทบต่อการนำไปใช้จริง โค้ดที่แก้ไขยังใช้งานได้ดังเดิม
```python
class Token:
    # ตัดเอา word ออกไป
    pos = ''
    ner = ''
    lang = ''
    is_first = False
    lemma = '' 

    def __init__(self, word):
        self.word = word
        self.lang = detect_lang(word)
```

ตัวอย่างการใช้เมท็อดตัวสร้าง เป็นดังนี้

```python
my_token = Token('firm')
print(my_token.lang) # en
```

สังเกตจากโค้ดเบื้องต้นจะเห็นว่า เช่นเดียวกันกับเวลาเรียกใช้เมท็อดอื่น ๆ ไพทอนจะทราบเองโดยอัตโนมัติว่าเป็นการใช้เมท็อดของอ็อบเจกต์นั้น เวลาสร้างอ็อบเจกต์ของคลาส `Token` จึงใส่อาร์กิวเมนต์เพียง 1 ตัวเพื่อส่งให้กับเมท็อดตัวสร้าง ไม่ใช่สองตัว (`self` และ `word`) 


ในทำนองเดียวกันกับตัวแปรประจำคลาส เมท็อดในภาษาไพทอนไม่มีการแบ่งแยกระดับการเข้าถึง ทุกคลาส ทุกโปรแกรมสามารถเรียกใช้เมท็อดของคลาสอื่น ๆ ได้ และเมท็อดที่กำหนดขึ้นมาเองในคลาสหนึ่งก็สามารถเรียกใช้เมท็อดของคลาสอื่น ๆ ได้เช่นกัน 


## สิ่งสืบทอด (inheritance)

<!--จุดประสงค์ของย่อหน้านี้คืออะไรนะคะ 
1.	บอกว่าจริงๆ oop ก็ไม่ได้จำเป็นขนาดนั้น?
2.	อยากให้เป็นประโยคเชื่อมเพื่อบอกว่า oop มีประโยชน์นะ มีลักษณะ inheritance? 
ถ้าเป็นข้อสองน่าจะต้องมีย่อหน้าเชื่อมหน่อย อันนี้อ่านแล้วดูเหมือนโดดอยู่ย่อหน้าเดียว อ่านทั้งหัวข้อเสร็จยังบอกไม่ได้ว่าดีกว่ายังไง แค่บอกว่ามีลักษณะนี้
3. ลักษณะของ oop : inheritance มีปย.นะ?

หรือจริงๆ อาจต้องย้ายไปอยู่ส่วนอื่นของเนื้อหา เช่นตอนสรุป-->

ตอนนี้ผู้อ่านอาจจะยังไม่ได้เห็นประโยชน์ของการเขียนโปรแกรมเชิงอ็อบเจกต์เท่าไรนัก เพราะว่าอย่างไรเสียก็สามารถใช้ดิกชันนารีแทนคลาสได้ และสามารถเขียนโปรแกรมอย่างระมัดระวัง เพื่อไม่ให้เกิดการเข้าถึงข้อมูลผ่านคีย์ที่ไม่ได้มีอยู่ในดิกชันนารีได้ และยังสามารถเขียนฟังก์ชันแทนการเขียนเมท็อดได้ กล่าวคือถ้าหากผู้เขียนโค้ดจัดระเบียบโค้ดดี ๆ ก็ทำให้สามารถหลีกเลี่ยงข้อผิดพลาดในการเขียนโปรแกรมได้ 

การใช้สิ่งสืบทอด (inheritance) เป็นรูปแบบการใช้งาน (feature) ที่ทำให้การเขียนโปรแกรมสะดวกขึ้น สิ่งสืบทอดเป็นการรับทอดลักษณะประจำและเมท็อดจากคลาสหนึ่งไปยังอีกคลาสหนึ่ง  ซึ่งทำให้ผู้เขียนโปรแกรมสามารถนำโค้ดที่เขียนไว้แล้วมาใช้ใหม่ได้ คลาสที่เป็นซับคลาส (subclass) รับทอด (inherit) เอาลักษณะประจำ และเมท็อดจากคลาสที่เป็นซูเปอร์คลาส (superclass) และซับคลาสสามารถลบล้าง (override) เมท็อดที่สืบทอดมาให้เป็นไปตามต้องการได้ด้วย ดังนั้นจึงสามารถกล่าวได้ว่าซับคลาสทำทุกอย่างที่ซูเปอร์คลาสทำได้ และอาจจะมีเมท็อดหรือลักษณะประจำอื่น ๆ เพิ่มเติมขึ้นมาได้อีกด้วย

<!--ควรเพิ่มมั้ยว่า เป็นคลาสของโมดูลมาตรฐานหนึ่งในไพทอน ต้อง import collections from collections มาก่อน -->
<!--ควรอธิบายตรงไหนซักจุดถึงความเชื่อมโยงระหว่าง OOP, library มั้ยคะ แบบอันไหนเป็น oop บ้างอันไหนไม่เป็นบ้าง-->
ตัวอย่างเช่น คลาสที่ชื่อว่าเคาน์เตอร์ (`Counter`) ที่มากับไพทอน เป็นซับคลาสของคลาสที่ชื่อว่าดิกชันนารี (`dict`) หมายความว่าเคาน์เตอร์มีตัวแปรและเมท็อดของดิกชันนารีทั้งหมด แต่สามารถปรับแก้เมท็อดที่สืบทอดมา และเพิ่มเมท็อดอื่น ๆ เพิ่มเติมเข้าไปได้อีกด้วย เพราะฉะนั้นเมื่อผู้เขียนโปรแกรมทราบแล้วว่า `Counter` เป็นซับคลาสของ `dict` ก็จะสามารถอนุมานได้ว่า `Counter` จะต้องมีเมท็อด `items` `keys` `values` `update` `clear` และเมท็อดอื่น ๆ ที่ `dict` มี เพราะว่า `Counter` รับทอดเมท็อดเหล่านี้มาจากซูเปอร์คลาสซึ่งก็คือ `dict` นอกจากนั้นแล้วเนื่องจาก `Counter` เป็นซับคลาสจึงอาจจะมีเมท็อดพิเศษเพิ่มเข้ามาอย่างเช่น `most_common` 

การกำหนดให้ `Counter` เป็นซับคลาสของ `dict` มีข้อดีคือ ทำให้ `Counter` สามารถใช้กลไกในการเก็บข้อมูลในลักษณะประจำ และกลไกการเข้าถึงข้อมูลได้เหมือน `dict` ทุกประการ โดยที่ไม่ต้องคัดลอกโค้ดของ `dict` มาทั้งหมด และยังสามารถปรับแก้เมท็อดที่สืบทอดมาได้อีกด้วย เช่น ลบล้างตัวสร้างที่สืบทอดมาเพื่อเปลี่ยนให้ตัวสร้างให้สามารถสร้างจากลิสต์ได้ ลบล้างเมท็อดการค้นหาแวลูจากคีย์เพื่อเปลี่ยนให้คืนค่าเป็น 0 ถ้าหากเรียกใช้คีย์ที่ไม่เคยปรากฏมาก่อน เป็นต้น 

การกำหนดคลาสให้เป็นซับคลาสของอีกคลาสหนึ่งสามารถทำได้ตอนที่เขียนโค้ดส่วนที่กำหนดคลาส โดยใช้คียเวิร์ด `class` ตามด้วยชื่อคลาสและใส่ชื่อซุปเปอร์คลาสในวงเล็บ ตามด้วย `:` เช่น

```python
class Counter(dict):
```

รูปแบบสำหรับการกำหนดคลาสและซับคลาสคือ 

```python
class ชื่อซับคลาส(ชื่อซูเปอร์คลาส):
    
    ชื่อลักษณะประจำ

    ตัวสร้าง (หากไม่เหมือนกับซูเปอร์คลาส)

    เมท็อดเพิ่มเติมจากซูเปอร์คลาส 

    เมท็อดที่ต้องการลบล้างจากซูเปอร์คลาส
```

ในมุมมองของผู้ใช้คลาส เมื่อผู้ใช้ทราบว่าคลาสที่ใช้เป็นซับคลาสของคลาสอะไร ผู้ใช้ก็จะทราบทันทีว่าคลาสที่ต้องการใช้มีไว้ทำอะไร มีเมท็อดอะไรบ้าง ยกตัวอย่างเช่น  `Counter` และ `dict` หากทราบแล้วว่าเคาน์เตอร์เป็นซับคลาสของดิกชันนารี ก็จะสามารถอนุมานได้ว่าเคาน์เตอร์สามารถทำทุกสิ่งที่ดิกชันนารีทำได้ โดยอาจมีส่วนที่แตกต่างกัน
<!--เติมไปว่าต่างจาก dict ที่ถ้า access ที่ไม่มีจะ error ไม่รู้ว่าชัดเจนขึ้นมั้ย หรือยกตัวอย่างผิด รบกวนเช็กเพิ่มหน่อยค่ะ-->
 เช่น ผู้ใช้คลาสเคาน์เตอร์จำเป็นต้องรู้เพิ่มว่าเคาน์เตอร์มีแวลูเป็นตัวเลขเท่านั้น และคีย์ที่ไม่ได้ปรากฏในเคาน์เตอร์จะมีแวลูเป็น 0 เสมอ ต่างจากดิกชันนารีที่ถ้าพยายามเข้าถึงแวลูของคีย์ที่ไม่ได้ปรากฏในดิกชันนารี ก็จะโยนข้อผิดพลาดขึ้นมา ลักษณะดังกล่าวเรียกว่าการลบล้างเมท็อด หรือการกำหนดพฤติกรรมของเมท็อดที่สืบทอดมาจากซุปเปอร์คลาสใหม่ โดยการเขียนเมท็อดที่มีชื่อและพารามิเตอร์เหมือนกันในคลาสย่อย เพื่อเปลี่ยนการทำงานของเมท็อดนั้นให้เป็นไปตามที่ต้องการ


ในมุมมองของนักเขียนโปรแกรม การใช้สิ่งสืบทอดทำให้ผู้เขียนโปรแกรมสามารถนำโค้ดที่เขียนไว้แล้วมาใช้ใหม่ได้ และปรับแก้เฉพาะส่วนที่ต้องการเท่านั้น ทำให้ประหยัดเวลาในการเขียนโค้ดลงไปได้มาก



## ตัวอย่างการใช้สิ่งสืบทอด
การเปลี่ยนให้เป็นโทเค็น (tokenizer) เป็นกระบวนการแรกในการประมวลผลภาษาธรรมชาติ คือการตัดแบ่งสตริงของข้อมูลภาษาให้เป็นหน่วยที่ชื่อว่าโทเค็น (token) ซึ่งหมายถึงหน่วยที่เล็กที่สุดที่เหมาะในการประมวลผล โทเค็นส่วนใหญ่แล้วจะคล้ายคลึงกับคำเป็นส่วนใหญ่ โทเค็นจะเป็นอะไรนั้นขึ้นอยู่กับการตัดสินใจของผู้ที่วิเคราะห์และประมวลผลข้อความว่าจะปรับโทเค็นให้มีลักษณะอย่างไร 

ยกตัวอย่างเช่น หากผู้เขียนโปรแกรมต้องการสร้างตัวตัดคำภาษาไทย โดยการใช้รายการคำศัพท์เป็นเกณฑ์ในการตัด และต้องการตั้งเงื่อนไขว่าหากได้รับประโยคที่เคยโดนตัดคำมาแล้ว เพื่อความรวดเร็ว ให้คืนค่าเป็นผลลัพธ์เดิม ผู้เขียนโปรแกรมอาจจะออกแบบคลาส `ThaiTokenizer` ขึ้นมาให้มีลักษณะดังนี้

```python
class ThaiTokenizer:
    vocab_list = [x.strip() for x in open('thai-vocab.txt').readlines()]
    cache = {}

    def __init__(self):
        pass

    def tokenize(self, sentence):
        if sentence in self.cache:
            return self.cache[sentence]
        
        segmented = segment(self.vocab_list, sentence)
        self.cache[sentence] = segmented
        return segmented
    
    def add_more_vocab(word_list):
        self.vocab_list.extend(word_list)
```

คลาสที่ชื่อว่า `ThaiTokenizer` มีลักษณะประจำทั้งหมด 2 ตัว คือ `vocab_list` และ `cache` และมีเมท็อดที่ชื่อว่า `tokenize` และ `add_more_vocab` โดย `tokenize` จะใช้ฟังก์ชันที่ชื่อว่า `segment` (ฟังก์ชันสมมติใช้ในการตัดคำ) ในการตัดคำ และ `add_more_vocab` จะใช้ในการเพิ่มคำศัพท์เข้าไปใน `vocab_list` และเมท็อดตัวสร้าง `__init__` จะไม่ทำอะไรเลย 

เมื่อผู้ใช้ต้องการตัดคำสามารถทำได้ดังนี้
```python
tokenizer = ThaiTokenizer()
print(tokenizer.tokenize('สวัสดีครับ')) # ['สวัสดี', 'ครับ']
```

สมมติว่าผู้เขียนโปรแกรมต้องการสร้างคลาสใหม่ที่มีความสามารถเพิ่มเติม คือสามารถตัดคำที่มีศัพท์ทางการแพทย์ เช่น ชื่อโรค ชื่อยา ได้ เพื่อนำไปใช้ประมวลผลเอกสารที่มาจากโรงพยาบาล จะสังเกตได้ว่าคลาสใหม่ที่ต้องการสร้างนี้ แท้จริงแล้วก็ต้องมีความสามารถทั้งหมดของ `ThaiTokenizer` เพียงแต่ต้องมีคำศัพท์เพิ่มเติมใน `vocab_list` เมื่อสังเกตเห็นลักษณะดังกล่าวแล้ว ผู้เขียนโปรแกรมก็ควรจะเขียนให้คลาสใหม่นี้เป็นซับคลาสของ `ThaiTokenizer` ดังนี้
```python
class MedicalThaiTokenizer(ThaiTokenizer):

    def __init__(self, drug_name_list, disease_name_list):
        self.vocab_list.extend(drug_name_list)
        self.vocab_list.extend(disease_name_list)
        self.drug_name_list = drug_name_list
        self.disease_name_list = disease_name_list

    def contains_medical_terms(self, token_list):
        for token in token_list:
            if token in self.drug_name_list or token in self.disease_name_list:
                return True
        return False
```
ในตัวอย่างดังกล่าว ได้มีการลบล้างเมท็อดตัวสร้างของ `ThaiTokenizer` ซึ่งสืบทอดมาจากซุปเปอร์คลาส โดยที่เมท็อดตัวสร้างของ `MedicalThaiTokenizer` จะบังคับให้ผู้ใช้ระบุคำศัพท์ที่เป็นชื่อยา และชื่อโรคเพิ่มเติม ก่อนที่ตัวสร้างจะเพิ่มเข้าไปใน `vocab_list` และเพิ่มตัวแปรที่เป็นลักษณะประจำอีกสองตัว ได้แก่ `drug_name_list` และ `disease_name_list` นอกจากนั้น ในตัวอย่างดังกล่าวก็ได้มีการเพิ่มเมท็อดที่ชื่อว่า `contains_medical_terms` ซึ่งใช้ตรวจสอบว่าประโยคที่ผู้ใช้ต้องการตัดคำมีคำที่เป็นชื่อยาหรือชื่อโรคประกอบอยู่หรือไม่

เมื่อผู้ใช้ต้องการใช้คลาสใหม่ ก็สามารถเรียกใช้ได้ดังนี้
```python
tokenizer = MedicalThaiTokenizer(['เพนนิซิลิน', 'แอสไพริน', 'ไวโคดิน'], ['เล็บโตสไปโรสิส', 'ไมเกรน'])
print(tokenizer.tokenize('เพนนิซิลินเป็นยาที่ใช้ในการรักษาโรคเบาหวาน')) # ['เพนนิซิลิน', 'เป็น', 'ยา', 'ที่', 'ใช้', 'ใน', 'การ', 'รักษา', 'โรค', 'เบาหวาน']
```
ข้อสังเกตหนึ่งคือในโค้ดที่กำหนดคลาสใหม่นี้ ไม่ได้มีส่วนของเมท็อดที่ชื่อว่า `tokenize` อยู่ เนื่องจาก `MedicalThaiTokenizer` เป็นซับคลาสของ `ThaiTokenizer` และ `ThaiTokenizer` มีเมท็อดที่ชื่อว่า `tokenize` อยู่แล้ว จึงได้รับการสืบทอดลงมาถึง `MedicalThaiTokenizer` ด้วย ไม่จำเป็นต้องเขียนขึ้นมาใหม่

จากตัวอย่างดังกล่าว จะเห็นได้ว่าลักษณะของสิ่งสืบทอดนั้นช่วยให้การจัดระเบียบและนำโค้ดเก่ามาใช้นั้นสามารถทำได้อย่างสะดวก และเป็นระบบ หากแต่การนำลักษณะของสิ่งสืบทอดมาใช้นี้ มีข้อเสียอยู่คือทำให้โค้ดทั้งหมดไม่ได้อยู่ในที่เดียวกัน เช่น กรณีข้างต้น หากผู้ใช้หรือผู้เขียนโค้ดต้องการทราบว่า `MedicalThaiTokenizer` มีเมท็อดอะไรบ้าง ผู้ใช้จำต้องไปเปิดโค้ดของซุปเปอร์คลาส `ThaiTokenizer` ดู ซึ่งลักษณะของโค้ดที่กระจัดกระจายนี้อาจก่อให้เกิดอุปสรรคต่อการทำความเข้าใจโค้ด การนำโค้ดไปใช้ต่อ และการบำรุงรักษาโค้ดได้ โดยเฉพาะเมื่อผู้เขียนโค้ดนั้นทำให้ตระกูลของคลาสมีความซับซ้อนมากเกินไป เช่น `LegalMedicalThaiTokenizer` เป็นซับคลาสของ `MedicalThaiTokenizer` ซึ่งเป็นซับคลาสของ `ThaiTokenizer` อีกครั้งหนึ่ง เพราะฉะนั้นบางเมท็อดของ `LegalMedicalThaiTokenizer` อาจจะมาจาก 
 `MedicalThaiTokenizer` หรือ `ThaiTokenizer` ได้ เป็นต้น


## สรุป
<!--เติมว่าคุณสมบัติหลักๆของ oop แฝงในภาษาคืออะไร ไม่ได้ชี้ชัดมาก่อนว่าหมายความว่าอย่างไร มีเพียงบอกตอนขึ้น #class and object ว่าภาษาไพธอนรองรับคุณลักษณะอะไรบ้าง-->
<!--ทั้งบทยังไม่มีส่วนที่บอกว่าโปรแกรมแบบไหนที่เหมาะกับลักษณะ OOP หรือเขียนโค้ด ฟังก์ชันธรรมดา คำว่าซับซ้อนสูง ต้องการความยืดหยุ่นคือยังไง ควรเพิ่ม-->
ในการเขียนโปรแกรม ผู้เขียนโปรแกรมต้องตัดสินใจในการออกแบบรูปแบบโปรแกรมว่าการเขียนโปรแกรมเชิงอ็อบเจกต์ หรือ OOP นั้นเหมาะสมกับโจทย์ที่ได้รับหรือไม่ เนื่องจากการเขียนโปรแกรมภาษาไพทอนนั้น ไม่ได้มีการบังคับใช้ OOP ในการเขียนโปรแกรม เพียงแต่มีลักษณะคุณสมบัติหลัก ๆ ของ OOP แฝงอยู่ในภาษา 

ทั้งนี้การเขียนโปรแกรมเชิงอ็อบเจกต์นั้นก็มีข้อดีและข้อเสีย ข้อดี คือ ทำให้โค้ดมีความสะอาด อ่านง่าย การแบ่งโปรแกรมออกเป็นส่วนย่อย ทำให้ช่วยความสามารถจัดการกับความซับซ้อนของโปรแกรมได้ดีขึ้น นอกจากนี้ ยังสนับสนุนการนำโค้ดไปใช้ซ้ำ และทำให้การปรับเปลี่ยนโค้ดในภายหลังสามารถทำได้ง่ายขึ้น เพราะสามารถแก้ไขเฉพาะบางคลาสหรือเมท็อดได้โดยไม่กระทบกับส่วนอื่นของโปรแกรม

อย่างไรก็ตาม ข้อเสียของการใช้ OOP ในการเขียนโปรแกรมนั้นคืออาจทำให้โค้ดมีความซับซ้อนเกินความจำเป็นในบางสถานการณ์ อีกทั้งหากออกแบบรูปแบบโปรแกรมไม่ดี อาจนำไปสู่โค้ดที่มีความยุ่งเหยิง เกิดการอ้างอิงที่ซับซ้อน ซึ่งทำให้การบำรุงรักษารวมถึงการนำไปใช้และแก้ไขโค้ดในภายหลังนั้นทำได้ลำบาก

ด้วยเหตุนี้ การตัดสินใจเลือกใช้การเขียนโปรแกรมเชิงอ็อบเจกต์นั้นจึงควรพิจารณาจากลักษณะของงานและทีมผู้พัฒนา หากงานที่ได้รับมอบหมายนั้นมีความซับซ้อนสูง ต้องอาศัยความยืดหยุ่นในการจัดการกับอ็อบเจกต์และข้อมูล หรือมีการนำโค้ดไปร่วมใช้งานกับระบบที่ใช้ OOP อยู่แล้ว การเลือกใช้แนวทางการเขียนโปรแกรมเชิงอ็อบเจกต์จะเป็นทางเลือกที่เหมาะสมและยืดหยุ่น แต่หากในกรณีที่งานที่ได้รับมอบหมายนั้นเป็นงานที่เรียบง่ายหรือทีมผู้พัฒนานั้นไม่คุ้นชินหรือยังไม่เชี่ยวชาญในการเขียนโปรแกรมเชิงอ็อบเจกต์ ก็สามารถเลือกใช้แนวทางอื่นที่ไพทอนรองรับได้อย่างมีประสิทธิภาพเช่นกัน