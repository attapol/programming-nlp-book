# บทที่ 3 </br> โครงสร้างข้อมูล (Data Structure) I

โครงสร้างข้อมูล (data structure) เป็นกลไกที่ใช้สำหรับการจัดเก็บข้อมูลในรูปแบบที่มีโครงสร้าง เพื่อให้สามารถจัดเก็บ ค้นหา และจัดการข้อมูลได้อย่างมีประสิทธิภาพ การเข้าใจโครงสร้างข้อมูลเป็นสิ่งสำคัญอย่างยิ่งสำหรับโปรแกรมเมอร์ โดยเฉพาะอย่างยิ่งผู้ที่สนใจทางด้านวิทยาการข้อมูล (data science) เนื่องจากต้องมีการจัดเก็บ เคลื่อนย้าย และประมวลผลข้อมูลอยู่เป็นประจำ


```{admonition} จุดมุ่งหมายของบทนี้
- เลือกใช้โครงสร้างข้อมูลประเภทสต์ (list) ดิกชันนารี (dictionary) ทูเปิล (tuple) เคาน์เตอร์ (counter) และเซต (set) ให้เข้ากับโจทย์ได้อย่างถูกต้อง
- การใช้ `for` และ `while` ร่วมกับโครงสร้างข้อมูลที่ซับซ้อนขึ้น
- ใช้เมท็อดของโครงสร้างข้อมูลเพื่อแก้โจทย์ได้อย่างมีประสิทธิภาพ
```

โครงสร้างข้อมูลมีอยู่หลายประเภท ซึ่งในบทนี้เราจะศึกษาและฝึกปฏิบัติการใช้โครงสร้างข้อมูลประเภทลิสต์ (list) ดิกชันนารี (dictionary) ทูเปิล (tuple) เคาน์เตอร์ (counter) และเซต (set) ในการเก็บข้อมูล การเลือกใช้โครงสร้างข้อมูลต้องพิจารณาถึง 3 ปัจจัยหลัก

1. ความถูกต้องของข้อมูล: ข้อมูลจะต้องไม่สูญหายหรือบิดเบือนไปจากเจตนาของผู้ใช้งาน เช่น โครงสร้างข้อมูลบางประเภทไม่เก็บข้อมูลที่ซ้ำ หรือไม่เรียงลำดับข้อมูลที่เก็บไว้
2. ความรวดเร็วในการประมวลผล: โครงสร้างข้อมูลแต่ละประเภทมีวิธีการจัดเก็บข้อมูลที่แตกต่างกัน ทำให้เวลาที่ใช้ในการค้นหาและดึงข้อมูลมาใช้งานจึงต่างกันออกไป
3. ความสะดวกในการใช้งาน: โครงสร้างข้อมูลแต่ละประเภทมีเมท็อดหรือคำสั่งที่แตกต่างกัน ทำให้งานบางประเภทสามารถทำได้สะดวกกว่า เช่น ลิสต์มีเมท็อดที่สามารถดึงข้อมูลตามลำดับได้ง่าย หากเราต้องการดึงข้อมูลตามลำดับเช่นนี้ ควรเลือกใช้ลิสต์ในการเก็บข้อมูล

ในบทนี้และบทถัดไป เราจะศึกษาวิธีการใช้งานโครงสร้างข้อมูลในแง่มุมต่าง ๆ ดังนี้
1. วิธีการสร้างโครงสร้างข้อมูล
2. วิธีการเพิ่มข้อมูลเข้าไปในโครงสร้าง
3. วิธีการแก้ไขข้อมูลที่อยู่ในโครงสร้าง
4. วิธีการดึงข้อมูลออกมาโดยการใช้วงวน
5. วิธีการใช้เมท็อดต่าง ๆ ของโครงสร้างข้อมูล
6. การพิจารณาข้อดีข้อเสียของโครงสร้างข้อมูลแต่ละประเภท

```{margin} คำศัพท์
โครงสร้างข้อมูล คือ วิธีการจัดเก็บข้อมูลในคอมพิวเตอร์ เพื่อให้ค้นหา และประมวลผลข้อมูลได้อย่างมีประสิทธิภาพ
```


## ลิสต์

ลิสต์ (list) เป็นโครงสร้างข้อมูลที่ใช้ในการจัดเก็บข้อมูลเป็นลำดับ ซึ่งข้อมูลภายในลิสต์จะถูกเรียงตามลำดับตามกำหนด ลิสต์มีคุณสมบัติที่สามารถเก็บข้อมูลได้หลายประเภทในคราวเดียวกัน ไม่ว่าจะเป็นจำนวนเต็ม จำนวนทศนิยม หรือสตริง

ลิสต์มีความคล้ายคลึงกับสตริงอย่างมาก ในความเป็นจริงสายอักขระก็ถือเป็นลิสต์ชนิดหนึ่งที่เก็บตัวอักขระเท่านั้น เพียงแต่สายอักขระมีเมท็อดบางอย่างที่แตกต่างจากลิสต์ ดังนั้นการทำความเข้าใจวิธีการทำงานของสายอักขระจะช่วยให้เข้าใจการทำงานของลิสต์ได้ดีขึ้น

### การสร้างลิสต์ด้วย `[]`
ลิสต์สามารถสร้างได้โดยใช้เครื่องหมาย `[]` ในการคร่อมข้อมูล โดยไม่สามารถใช้ `()` หรือ `{}` แทนได้
```python
my_first_list = []
```
ในตัวอย่างนี้ตัวแปร `my_first_list` เป็นลิสต์เปล่าที่ไม่มีข้อมูลหรือสมาชิกใด ๆ

หากต้องการสร้างลิสต์ที่เป็นค่าคงที่ (literal) กล่าวคือสมาชิกของลิสต์ถูกระบุเอาไว้โดยตรงในโค้ด เราสามารถใช้ `[]` คร่อมข้อมูลที่ต้องการเก็บ (เรียกว่า สมาชิกของลิสต์) โดยที่ข้อมูลแต่ละตัวจะเป็น `int float` หรือสตริงก็ได้คั่นด้วยเครื่องหมาย `,` 

สมมติว่าเราต้องการสร้างลิสต์ที่เก็บยอดขายหกเดือนแรก และสร้างอีกลิสต์เพื่อเก็บชื่อเดือน
```python
sales_list = [12, 10, 5, 2, 5 10]
months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'June']
```
ตัวแปร `sales_list` และ `months` เป็นลิสต์เก็บ `int` และสตริงตามลำดับ ซึ่งทั้งสองลิสต์มีสมาชิกทั้งหมด 6 ตัวเท่ากัน

นอกจากนี้ ลิสต์ยังสามารถเก็บข้อมูลต่างประเภทได้ด้วย แต่การใช้งานในลักษณะนี้อาจทำให้เกิดความสับสน เช่น

```python
sales_list = ['Jan', 12, 'Feb', 10]
```

โปรแกรมเมอร์มักไม่แนะนำให้ใช้ลิสต์ในลักษณะนี้ เนื่องจากอาจทำให้ยากต่อการทำความเข้าใจว่าข้อมูลแต่ละตัวในลิสต์มีความหมายอย่างไร ดังนั้นจึงควรให้ข้อมูลภายในลิสต์เป็นประเภทเดียวกันเพื่อความชัดเจน

### ชื่อตัวแปรที่เก็บลิสต์
ชื่อตัวแปรที่ใช้ในการเก็บลิสต์โดยกฎแล้วจะเป็นอะไรก็ได้ แต่เพื่อทำให้โค้ดเข้าใจได้ง่ายขึ้น โปรแกรมเมอร์มักตั้งชื่อลิสต์ตามสิ่งที่เก็บอยู่ตามด้วย `_list` หรือเปลี่ยนให้เป็นพหูพจน์แทน เช่น 
- ถ้าลิสต์เก็บนามสกุลก็ควรจะตั้งชื่อตัวแปรว่า `last_name_list` หรือ `last_names`  
- ถ้าลิสต์เก็บจำนวนคำที่อยู่ในแต่ละประโยค ควรจะตั้งชื่อตัวแปรว่า `num_words_list` หรือ `num_words` แต่ว่าจากชื่อ `num_words` อาจจะกำกวมว่าเก็บไว้เป็น `int` ตัวเดียวเดี่ยว ๆ หรือไม่  

### การสร้างลิสต์จากสตริง

```python
sentence = "Let's go crazy crazy crazy 'til we see the sun"
word_list = sentence.split(' ')
```

สตริงเมท็อด`.split` ใช้เวลาเราต้องการเปลี่ยนสตริงให้เป็นลิสต์ โดยที่ต้องกำหนดว่าจะใช้สตริงอะไรแบ่งสมาชิกแต่ละตัว ในตัวอย่างนี้เราใช้ `' '` ช่องว่างในการแบ่ง ในการประมวลผลภาษาธรรมชาติเราใช้คำสั่งนี้บ่อยมากในการตัดคำ ซึ่งก็คือการเปลี่ยนสตริงให้เป็นลิสต์ของคำ

### การหาความยาวของลิสต์ (จำนวนสมาชิก)

ไพทอนมีฟังก์ชันบิวท์อิน `len` ที่ใช้หาจำนวนสมาชิกของลิสต์ ซึ่งสามารถใช้ได้กับโครงสร้างข้อมูลอื่น ๆ ของไพทอนทั้งหมดอีกด้วย เช่น

```python
sentence = "Let's go crazy crazy crazy 'til we see the sun"
word_list = sentence.split(' ')
len(word_list) #---> 10
```

 ฟังก์ชันนี้จะคืนค่า `int` เสมอ ตัวอย่างที่ใช้บ่อย ๆ คือใช้ในการสร้างลิสต์จากสตริงเพื่อนับจำนวนคำที่อยู่ในประโยคหรือข้อความ เนื่องจากภาษาที่ใช้ตัวเขียนเป็นตัวลาตินสามารถตัดคำโดยใช้คำสั่ง `split` ได้ง่าย ๆ ถึงแม้ว่าจะไม่ได้แม่นยำเสมอไป

### เข้าถึงสมาชิกในลิสต์โดยใช้ดัชนี

การเข้าถึงสมาชิกแต่ละตัว เราจะใช้ตัวดำเนินการ `[]` คร่อมดัชนี และกฎการใช้ดัชนีเหมือนกับสตริงทุกประการ สมาชิกตัวแรกอยู่ที่ดัชนี 0 และสามารถใช้ดัชนีติดลบ ในการนับดัชนีถอยหลังจากท้ายลิสต์ได้ โดยดัชนี -1 หมายถึงสมาชิกตัวสุดท้าย, ดัชนี -2 หมายถึงสมาชิกถัดจากตัวสุดท้ายเป็นต้น

ตัวอย่างเช่น หากเรามีลิสต์ดังนี้ 
```python
words = ["Let's", 'go', 'crazy', 'crazy', 'crazy', "'til", 'we', 'see', 'the', 'sun']
```
เราสามารถเข้าถึงสมาชิกในลิสต์ได้โดยใช้ดัชนี เช่น

| คำสั่ง 			  | ผลลัพธ์ |
| -------			|--------|
| `words[0]`			| `"Let's"`	 |
| `words[1]`			| `'go'`	 |
| `words[-3]`			| `'see'`	 |
| `words[5]`			| `"'til"`	 |

ในกรณีที่พยายามเข้าถึงดัชนีที่ไม่อยู่ในช่วงของลิสต์ เช่น
```python
words[20]
```
จะทำให้เกิดข้อผิดพลาดที่เรียกว่า `IndexError` เนื่องจากไม่มีสมาชิกอยู่ที่ดัชนี 20 วิธีที่ดีที่สุดในการหลีกเลี่ยงข้อผิดพลาดนี้คือการตรวจสอบขอบเขตของลิสต์ก่อนเรียกใช้ดัชนี

### การหั่นลิสต์
การหั่นลิสต์ (list slicing) เป็นการดึงข้อมูลบางส่วนจากลิสต์ โดยใช้เครื่องหมาย `[]` พร้อมระบุช่วงของดัชนีที่ต้องการ การหั่นลิสต์สามารถทำได้ในลักษณะเดียวกับการหั่นสตริง โดยใช้รูปแบบ `list[start:end]` ซึ่ง `start` คือดัชนีเริ่มต้น และ `end` คือดัชนีสุดท้าย (ไม่รวมค่าที่ดัชนี `end`) 

ตัวอย่างการใช้งานการหั่นลิสต์

```python
numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```
| คำสั่ง 			  | ผลลัพธ์ | คำอธิบาย |
| -------			|--------| ---------|
| `numbers[2:5]`		| `[2, 3, 4]`	| ดัชนี 2 ถึง 4 ไม่รวม 5 |
| `numbers[:4]`		| `[0, 1, 2, 3]`	| ดัชนีเริ่มต้นถึง 3 ไม่รวม 4 |
| `numbers[5:]`		| `[5, 6, 7, 8, 9]`	| ดัชนี 5 ถึงสุดท้าย |

การหั่นลิสต์เป็นฟังก์ชันที่มีประโยชน์อย่างมากในการจัดการข้อมูล เราสามารถใช้มันในการดึงข้อมูลย่อย ๆ ที่ต้องการได้โดยง่าย

### การวนซ้ำบนลิสต์ด้วยคำสั่ง `for` 
เราสามารถวนซ้ำ (iterate) บนลิสต์ได้ในลักษณะเดียวกับการวนซ้ำบนสตริง โดยสามารถวนซ้ำผ่านสมาชิกของลิสต์โดยตรง หรือวนซ้ำผ่านดัชนีของลิสต์ได้

ตัวอย่างเช่น หากเราต้องการนับจำนวนคำที่สะกดด้วยตัวพิมพ์เล็กทั้งหมดในลิสต์

```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for i in range(len(word_list)):
    word = word_list[i]  # ดึงค่าคำจากดัชนี i
    if word.islower():   # ตรวจสอบว่าคำเป็นตัวพิมพ์เล็กทั้งหมดหรือไม่
        count += 1
```

เราจะใช้ `i` เป็นตัวดัชนีในการเข้าถึงสมาชิกแต่ละตัวในลิสต์ โดยดัชนีจะเริ่มต้นที่ 0 และเพิ่มขึ้นเรื่อย ๆ จนถึง `len(word_list) - 1` อย่างไรก็ตาม การวนซ้ำแบบนี้ต้องมีการเรียกฟังก์ชัน `len(word_list)` และต้องเข้าถึงสมาชิกของลิสต์ดัชนีแยกออกมาอีกคำสั่ง `word_list[i]` ซึ่งอาจทำให้โค้ดยาวและซับซ้อนเกินไป

ภาษาไพทอนมีรูปแบบการวนซ้ำที่สามารถทำให้โค้ดกระชับและอ่านง่ายขึ้นโดยไม่ต้องใช้ดัชนี เช่น

```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for word in word_list:
	if word.is_lower(): # ตรวจสอบว่าสะกดด้วยตัวเล็กหรือไม่ 
		count += 1
```
โค้ดข้างบนนี้ได้ผลออกมาเหมือนกันทุกประการ เราวนซ้ำโดยตรงบนสมาชิกแต่ละตัวในลิสต์ ซึ่งทำให้โค้ดอ่านง่ายขึ้นและลดความซับซ้อนของการเข้าถึงสมาชิกแต่ละตัว  ในการวนรอบแรก `word` จะมีค่าเป็น `word_list[0]` ในการวนรอบที่สอง `word` จะมีค่าเป็น `word_list[1]` และเลื่อนไปเรื่อย ๆ จนวนผ่านสมาชิกครบทุกตัวในลิสต์ ตัวอย่างนี้ทำให้เห็นได้ว่าเราประหยัดโค้ดได้ค่อนข้างมาก โค้ดดูสะอาดตา และสะดวกสบายในการเขียนมากกว่าการวนซ้ำบนดัชนี

อย่างไรก็ตาม ในบางกรณีเราอาจต้องการทราบดัชนีของสมาชิกที่เรากำลังประมวลผลอยู่ด้วย ซึ่งในกรณีนี้เราสามารถใช้ฟังก์ชันบิวท์อิน `enumerate()` ที่ช่วยให้เราทราบทั้งดัชนีและค่าของสมาชิกในลิสต์พร้อมกัน เช่น
```python
word_list = ['Rick', 'and', 'Michonne', 'protect', 'Carl']
count = 0
for word_index, word in enumerate(word_list):
	if word.is_lower(): # ตรวจสอบว่าสะกดด้วยตัวเล็กหรือไม่ 
		count += 1
```
ฟังก์ชัน `enumerate()` จะคืนค่าทั้งดัชนีและสมาชิกในลิสต์ โดยในการวนรอบแรก `word_index` จะมีค่าเป็น 0 และ `word` จะมีค่าเป็น `'Rick'` ในการวนรอบถัดไป `word_index` จะมีค่าเป็น 1 และ `word` จะมีค่าเป็น `'and'` และต่อไปเรื่อยๆ จนครบทุกสมาชิกในลิสต์

การใช้ `enumerate()` มีประโยชน์มากเมื่อต้องการทำงานกับข้อมูลในลิสต์ที่ต้องอ้างอิงทั้งดัชนีและสมาชิกในลิสต์พร้อมกัน เช่น การประมวลผลข้อมูลที่ต้องพิจารณาสมาชิกก่อนหน้าและถัดไปในลิสต์

### ตัวดำเนินการของลิสต์ และฟังก์ชันแบบบิวท์อิน 

ลิสต์ใช้ตัวดำเนินการ และฟังก์ชันแบบบิวท์อิน หลายรูปแบบ ซึ่งคล้ายคลึงกับการทำงานของสตริง 

| Operator  		| ความหมาย 				  | ตัวอย่าง |
| --------  		| ---------				  | -------|
| + 				| ต่อลิสต์ (concatenate)		| `['a','a'] + ['b','b']` --> `['a','a','b','b']`| 
| * 				| ซ้ำลิสต์      				| `['a','b'] * 3` --> `['a','b','a','b','a','b']`| 
| `in`	    		| ตรวจสอบว่าข้อมูลชิ้นนี้อยู่ในลิสต์หรือไม่ 	| `'b' in ['a','b']` --> `True` |
|					|						   	|   `'c' in ['a','b']` --> `False`
| `not in`			| นิเสธของ `in`			  	|   `'b' not in ['a','b']` --> `False` |
| ==				| เท่ากันพอดีหรือไม่			| `['a','b'] == ['a','b']` --> `True` |
|					|							| `['a','b'] == ['a','b','c']`  --> `False` |
| `len(s)`			| คืนค่าความยาวลิสต์		 | `len(['a','b','c'])` --> 3 |

### การเขียนทับสมาชิกในลิสต์ด้วย `[]`
เราสามารถเขียนทับ (update) สมาชิกในลิสต์โดยใช้ดัชนีร่วมกับตัวดำเนินการกำหนดค่า `=` คล้าย ๆ กับการใช้ตัวแปร เราอาจจะคิดเสมือนว่าลิสต์เป็นการเก็บตัวแปรไว้หลาย ๆ ตัวแปร แบบเรียงลำดับกันตามที่เราต้องการ เช่น

```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
accountant_list[0] = 'โจ้'
print(accountant_list)
# เอาท์พุต: ['โจ้', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
```
ในตัวอย่างนี้ เราได้เขียนทับสมาชิกตัวแรกของลิสต์ (ดัชนี 0) จาก `'เจ'` เป็น `'โจ้'`

เรายังสามารถเขียนทับสมาชิกหลายตัวพร้อมกันได้โดยใช้ช่วงของดัชนี เช่น
```python
accountant_list[1:3] = ['แนน', 'ไอซ์']
print(accountant_list)
# เอาท์พุต: ['โจ้', 'แนน', 'ไอซ์', 'เมย์', 'มิว']
```
การเขียนทับสมาชิกในลิสต์จะช่วยให้สามารถเปลี่ยนแปลงข้อมูลภายในลิสต์ได้โดยตรง โดยไม่ต้องสร้างลิสต์ใหม่

## เมท็อดของลิสต์
ลิสต์ของเมท็อดของไพทอน เวอร์ชัน 3.12 มีอยู่ 11 เมท็อด แต่ว่าเมท็อดที่ใช้บ่อย ๆ ในการประมวลผลข้อมูลที่เกี่ยวข้องกับวิทยาการข้อมูล และการประมวลผลภาษาธรรมชาติ มีอยู่ 8 เมท็อด ได้แก่ `.append() .extend() .sort() .index() .count() .insert() .pop() .remove()` 

นอกจากนั้นยังมีฟังก์ชันบิวอินที่ใช้กับลิสต์ได้ 4 ฟังก์ชัน ได้แก่ `sort() sum() max() min()` ซึ่งเราจะเรียนรู้วิธีการใช้เมท็อดและฟังก์ชันเหล่านี้ในบทนี้

### เพิ่มข้อมูลเข้าท้ายลิสต์: `.append()`
เมท็อด `.append()` เป็นเมท็อดที่ใช้ในการเพิ่มสมาชิกใหม่เข้าไปที่ท้ายลิสต์ เมท็อดนี้จะทำการแก้ไขลิสต์โดยตรง ซึ่งหมายความว่าหลังจากเรียกใช้งานแล้ว ลิสต์เดิมจะถูกเปลี่ยนแปลงทันที

ตัวอย่างการใช้งาน `.append()`

```python
sales_list = [23, 12, 96] # สร้างลิสต์
sales_list.append(100) # เติมข้อมูลเข้าไป
print(sales_list) 
#เอาท์พุต คือ [23, 12, 96, 100]
```
ในตัวอย่างนี้ สมาชิกใหม่ `100` ถูกเพิ่มเข้าไปที่ท้ายลิสต์ `sales_list` และลิสต์ถูกปรับเปลี่ยนทันทีโดยไม่มีการสร้างลิสต์ใหม่

คุณสมบัติของเมท็อด `.append()`
- อินพุต: สมาชิกใหม่ที่ต้องการเพิ่มเข้าไปในลิสต์
- เอาท์พุต: `None` (เนื่องจากเมท็อดนี้แก้ไขลิสต์โดยตรง)

เมท็อด `.append()` เป็นหนึ่งในเมท็อดที่ได้ใช้งานบ่อยที่สุดในลิสต์ โดยเฉพาะในกรณีที่เราต้องการเก็บข้อมูลที่เปลี่ยนแปลงได้ เช่น การเพิ่มข้อมูลเข้าไปในลิสต์ทีละตัวในระหว่างการประมวลผลข้อมูล ตัวอย่างเช่น 

```python
numbers = []  # สร้างลิสต์เปล่า
for i in range(5):
    numbers.append(i * 2)  # เพิ่มค่าคูณสองของ i ลงในลิสต์
print(numbers)
# ผลลัพธ์: [0, 2, 4, 6, 8]
```

ในตัวอย่างนี้ เราใช้ `.append()` เพื่อเพิ่มข้อมูลเข้าไปในลิสต์ `numbers` ทีละตัว โดยค่าที่เพิ่มเข้าไปคือผลคูณของ `i` และ 2 ลิสต์สุดท้ายจะประกอบด้วยค่าคูณสองของตัวเลขตั้งแต่ 0 ถึง 4

### นำลิสต์หลาย ๆ ลิสต์มาต่อกัน: `.extend()`
เมท็อด `.extend()` ใช้สำหรับการเพิ่มสมาชิกหลายตัวจากลิสต์หนึ่งเข้ากับลิสต์อีกลิสต์หนึ่ง โดยสมาชิกทั้งหมดจากลิสต์ที่เป็นอินพุตจะถูกคัดลอกและเพิ่มต่อท้ายลิสต์ปัจจุบัน

ตัวอย่างการใช้งาน
```python
sales_first_six_months = [23, 12, 96, 100, 40, 10]
sales_last_six_months = [33, 44, 55, 66, 77, 88]
sales_first_six_months.extend(sales_last_six_months)
print(sales_first_six_months)
# เอาท์พุต: [23, 12, 96, 100, 40, 10, 33, 44, 55, 66, 77, 88]
```
ในตัวอย่างนี้ สมาชิกจากลิสต์ `sales_last_six_months` ถูกเพิ่มต่อท้ายลิสต์ `sales_first_six_months` โดยตรง

คุณสมบัติของเมท็อด `.extend()`
อินพุต: ลิสต์ที่ต้องการคัดลอกข้อมูลมาใส่
เอาท์พุต: `None` (เนื่องจากเมท็อดนี้แก้ไขลิสต์โดยตรง)

ข้อควรสังเกตคือ เมท็อด `.extend()` จะคัดลอกสมาชิกจากลิสต์ที่เป็นอินพุตมาใส่ในลิสต์ปัจจุบันโดยตรง ไม่ได้ย้ายสมาชิกจากลิสต์อินพุต นั่นหมายความว่า ลิสต์ที่เป็นอินพุตจะไม่ถูกเปลี่ยนแปลงแต่อย่างใด

### เรียงลำดับสมาชิกในลิสต์: `sorted(list)` และ `.sort()`

การเรียงลำดับลิสต์สามารถทำได้สองวิธี คือการใช้ฟังก์ชัน `sorted()` และการใช้เมท็อด `.sort()` ทั้งสองวิธีนี้ทำงานคล้ายกัน แต่มีความแตกต่างสำคัญที่ควรทราบ


#### ฟังก์ชัน `sorted()`
ฟังก์ชัน `sorted()` จะคืนค่าลิสต์ใหม่ที่มีสมาชิกเรียงลำดับตามลำดับที่กำหนด โดยลิสต์ต้นฉบับจะไม่ถูกเปลี่ยนแปลง ตัวอย่างเช่น

```python
sales_list = [23, 12, 96, 100]
sorted_sales_list = sorted(sales_list)
print(sorted_sales_list)
# ผลลัพธ์: [12, 23, 96, 100]
print(sales_list)
# ผลลัพธ์: [23, 12, 96, 100]  (ลิสต์ต้นฉบับไม่ถูกเปลี่ยนแปลง)
```

#### เมท็อด `.sort()`
เมท็อด `.sort()` จะทำการเรียงลำดับสมาชิกของลิสต์โดยตรง ซึ่งหมายความว่าลิสต์ต้นฉบับจะถูกเปลี่ยนแปลงและไม่คืนค่าลิสต์ใหม่ ตัวอย่างเช่น

```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.sort()
print(accountant_list)
# ผลลัพธ์: ['จอย', 'มิว', 'เจ', 'เมย์']
```
ในตัวอย่างนี้ ลิสต์ `accountant_list` ถูกเรียงลำดับใหม่ตามลำดับตัวอักษรโดยตรง

ข้อควรระวังเกี่ยวกับการเรียงลำดับคือ ฟังก์ชันและเมท็อดนี้จะเรียงลำดับสตริงภาษาไทยไม่ถูกต้องตามหลักพจนานุกรมไทย ฟังก์ชันเหล่านี้จะเรียงลำดับโดยเปรียบเทียบตัวอักษรแต่ละตัวตามลำดับการเขียน เพราะฉะนั้นจากตัวอย่าง `'เจ'` กับ `'เมย์'` มาทีหลัง `'จอย'` กับ `'มิว'` เพราะว่า `เ` มาหลัง `จ` และ `ม`

### หาผลรวม ค่าสูงสุด ต่ำสุด ในลิสต์: `sum(list)`, `max(list)` และ `min(list)`
ฟังก์ชันแบบบิวท์อิน `sum()`, `max()` และ `min()` เป็นฟังก์ชันที่ใช้ในการหาผลรวม ค่าสูงสุด และค่าต่ำสุดของสมาชิกในลิสต์ที่ประกอบด้วยข้อมูลประเภทตัวเลข

ตัวอย่างการใช้งาน
```python
class_size_list = [40, 50, 60, 70, 80]
print(sum(class_size_list))
# เอาท์พุต: 300
print(max(class_size_list))
# เอาท์พุต: 80
print(min(class_size_list))
# เอาท์พุต: 40
```
ในตัวอย่างนี้ ฟังก์ชัน sum() จะคืนค่าผลรวมของสมาชิกในลิสต์ ส่วนฟังก์ชัน max() จะคืนค่าสมาชิกที่มีค่ามากที่สุด และฟังก์ชัน min() จะคืนค่าสมาชิกที่มีค่าน้อยที่สุด

คุณสมบัติของฟังก์ชันเหล่านี้
- อินพุต: ลิสต์ที่ประกอบด้วยตัวเลข
- เอาท์พุต: ผลรวม หรือค่าสูงสุด หรือค่าต่ำสุด

ฟังก์ชันเหล่านี้ทำงานได้กับลิสต์ที่มีสมาชิกเป็นตัวเลขเท่านั้น หากสมาชิกในลิสต์เป็นข้อมูลประเภทอื่น เช่น สตริง อาจทำให้เกิดข้อผิดพลาด หรือในบางกรณี ไพทอนจะพยายามเรียงลำดับและเปรียบเทียบตัวอักษร ตัวอย่างเช่น

```python
string_list = ['apple', 'banana', 'cherry']
print(max(string_list))  # ค่าสูงสุดตามลำดับอักษร
# เอาท์พุต: 'cherry'
```
อย่างไรก็ตาม ควรระมัดระวังเมื่อใช้งานกับลิสต์ที่มีสมาชิกหลายประเภท เช่น
```python
mixed_list = [10, 'apple', 20]
print(max(mixed_list))  
```
จะทำให้เกิดข้อผิดพลาด `TypeError` เนื่องจากไม่สามารถเปรียบเทียบจำนวนเต็มกับสตริงได้

ข้อควรระวังอีกประการ คือฟังก์ชันเหล่านี้ไม่ใช่่เมท็อดแต่ว่าเป็นฟังก์ชันแบบบิวท์อิน เพราะฉะนั้นลิสต์ไม่สามารถเรียกใช้ในรูปแบบ `ลิสต์.sum()` ได้ หากมีการเรียกใช้งานในลักษณะนี้ จะเกิดข้อผิดพลาด `AttributeError` ซึ่งเป็นข้อผิดพลาดที่เกิดขึ้นเมื่อพยายามเรียกเมท็อดที่ไม่มีอยู่ในข้อมูลประเภทนั้น ๆ
```
>>> class_size_list.sum()
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'list' object has no attribute 'sum'
```
ข้อผิดพลาดนี้เกิดขึ้นเนื่องจากลิสต์ไม่มีเมท็อด `sum() `ผู้ใช้ควรใช้ฟังก์ชันในตัว `sum(class_size_list)` แทน

### หาดัชนีของสมาชิก: `.index()`
เมท็อด `.index()` ใช้สำหรับหาดัชนี (ตำแหน่ง) ของสมาชิกในลิสต์ โดยเมท็อดนี้จะคืนค่าดัชนีของสมาชิกตัวแรกที่พบ

ตัวอย่างการใช้งาน:
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว', 'จอย']
print(accountant_list.index('จอย'))
# เอาท์พุต: 2
```
ในตัวอย่างนี้ ค่าที่เมท็อด `.index()` คืนกลับมาคือ 2 ซึ่งเป็นดัชนีของสมาชิก `'จอย'` ที่ปรากฏตัวแรกในลิสต์ 

คุณสมบัติของเมท็อด `.index()`
- อินพุต: สมาชิกที่ต้องการทราบดัชนี(ตำแหน่งบนลิสต์)
- เอาท์พุต: ดัชนี

*ข้อควรระวัง*
- ก่อนใช้เมท็อดนี้ต้องเตือนความจำตัวเองก่อนว่าดัชนีของตำแหน่งแรกในลิสต์คือ 0  เช่น `'เจ'` ในตัวอย่างข้างต้นมีดัชนีเป็น 0 และ `'เมย์'` มีดัชนีเป็น 1
- หากสมาชิกที่ค้นหาปรากฏมากกว่าหนึ่งครั้ง เมท็อด `.index()` จะคืนค่าดัชนีของสมาชิกตัวแรกที่พบ ซึ่งค้นหาจากซ้ายไปขวาในลิสต์
- หากสมาชิกที่ค้นหาไม่มีอยู่ในลิสต์ เมท็อดจะทำให้เกิดข้อผิดพลาด `ValueError` เช่น
```
>>> accountant_list.index('จิว')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: 'จิว' is not in list
```

### นับจำนวนของสมาชิกที่ระบุมา: `.count()`
เมท็อด .count() ใช้สำหรับนับจำนวนครั้งที่สมาชิกที่กำหนดปรากฏอยู่ในลิสต์ เมท็อดนี้จะคืนค่าจำนวนครั้งที่พบ

ตัวอย่างการใช้งาน
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'เมย์', 'เมย์', 'มิว']
print(accountant_list.index('เมย์'))
# เอาท์พุต: 3
```
ในตัวอย่างนี้ ค่าที่เมท็อด `.count()` คืนกลับมาคือ 3 ซึ่งหมายความว่าสมาชิก `'เมย์'` ปรากฏอยู่ในลิสต์ทั้งหมด 3 ครั้ง

คุณสมบัติของเมท็อด `.count()`
- อินพุต: สมาชิกที่ต้องการนับจำนวนครั้งที่ปรากฏในลิสต์
- เอาท์พุต: จำนวนครั้งที่สมาชิกนั้นปรากฏในลิสต์


หากสมาชิกที่กำหนดไม่ปรากฏอยู่ในลิสต์ เมท็อด .count() จะคืนค่าเป็น 0 โดยไม่ทำให้เกิดข้อผิดพลาด เช่น
```python
print(accountant_list.count('จิว'))
# ผลลัพธ์: 0
```
ในกรณีนี้ ค่าที่ได้คือ 0 เนื่องจาก `'จิว'` ไม่ปรากฏอยู่ในลิสต์

### แก้ไขลิสต์: `.insert() .pop() .remove()`
เมท็อดเหล่านี้ใช้สำหรับการแก้ไขสมาชิกในลิสต์โดยตรง ไม่ว่าจะเป็นการเพิ่มสมาชิก แทรกสมาชิก หรือนำสมาชิกออกจากลิสต์ เมท็อดเหล่านี้จะปรับเปลี่ยนลิสต์ต้นฉบับโดยไม่สร้างลิสต์ใหม่ ทำให้ดัชนีของสมาชิกในลิสต์เปลี่ยนแปลงไปทุกครั้งที่มีการเพิ่มหรือนำสมาชิกออก ดังนั้น เมื่อใช้งานร่วมกับวงวนฟอร์ ควรต้องใช้ความระมัดระวัง เพราะอาจทำให้เกิดความสับสนในการจัดการดัชนีของสมาชิก

#### แทรกสมาชิกเข้าลิสต์: `.insert()`
เมท็อด `.insert()` ใช้สำหรับแทรกสมาชิกใหม่เข้าไปในตำแหน่งที่กำหนดภายในลิสต์ สมาชิกที่ถูกแทรกจะเลื่อนตำแหน่งสมาชิกที่มีอยู่เดิมต่อไปทางขวา

ตัวอย่างการใช้งาน

```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.insert(1, 'เจน')
print(accountant_list)
# ['เจ', 'เจน', 'เมย์', 'จอย', 'มิว']
```
ในตัวอย่างนี้ สมาชิก `'เจน'` ถูกแทรกเข้ามาที่ดัชนี 1 และสมาชิกที่อยู่ในลิสต์จะเลื่อนไปยังตำแหน่งถัดไป

คุณสมบัติของเมท็อด `.insert()`
- อินพุต: 
  1) ดัชนี(สามารถใช้ negativeดัชนีได้) 
  2) สมาชิกใหม่
- เอาท์พุต: `None` (เนื่องจากลิสต์ถูกแก้ไขโดยตรง)

หากดัชนีที่ระบุมากกว่าความยาวของลิสต์ เมท็อดจะทำการเพิ่มสมาชิกใหม่ต่อท้ายลิสต์โดยอัตโนมัติ และไม่ทำให้เกิดข้อผิดพลาด

#### นำสมาชิกออกจากลิสต์: `.remove()`
เมท็อด `.remove()` ใช้สำหรับลบสมาชิกตัวแรกที่มีค่าตรงกับข้อมูลที่ระบุ เมท็อดนี้จะทำการค้นหาจากซ้ายไปขวา และลบสมาชิกตัวแรกที่พบ

ตัวอย่างการใช้งาน
```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
accountant_list.remove(2)
print(accountant_list)
# ['เจ', 'เมย์', 'มิว']
```
ในตัวอย่างนี้ สมาชิก `'จอย'` ตัวแรกที่พบในลิสต์จะถูกลบออก

คุณสมบัติของเมท็อด `.remove()`
- อินพุต: ค่าของสมาชิกที่ต้องการลบออกจากลิสต์
- ผลลัพธ์: `None`


หากไม่มีสมาชิกที่ตรงกับค่าที่ระบุ เมท็อด`.remove()` จะทำให้เกิดข้อผิดพลาด `ValueError` เช่น
```
>>> accountant_list.remove('จิว')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: list.remove(x): x not in list
```

#### นำสมาชิกออกจากลิสต์: `.pop()`
เมท็อด `.pop()` ใช้สำหรับนำสมาชิกออกจากลิสต์ตามดัชนีที่กำหนด และคืนค่าสมาชิกนั้นกลับมา เมท็อดนี้จะลบสมาชิกที่ตำแหน่งที่ระบุ และหากไม่มีการระบุดัชนี จะลบสมาชิกตัวสุดท้ายในลิสต์

ตัวอย่างการใช้งาน

```python
accountant_list = ['เจ', 'เมย์', 'จอย', 'มิว']
removed_member = accountant_list.pop(2)
print(accountant_list)
# ['เจ', 'เมย์', 'มิว']
print(removed_member)
# จอย
```
ในตัวอย่างนี้ สมาชิกที่ดัชนี 2 (`'จอย'`) ถูกนำออกจากลิสต์และคืนค่าให้ตัวแปร `removed_member`

คุณสมบัติของเมท็อด `.pop()`
- อินพุต: ดัชนีที่ต้องการนำสมาชิกออก (สามารถใช้ดัชนีติดลบได้) 
- เอาท์พุต: สมาชิกที่ถูกลบออก 

ลิสต์จะคืนค่าสมาชิกที่อยู่ที่ดัชนีที่กำหนดมาให้ จากนั้นก็จะดีดเอาสมาชิกตัวนั้นออกไป (เมท็อดนี้เลยชื่อว่า `pop` ซึ่งแปลว่าดีดออก) หากดัชนีที่ระบุเกินความยาวของลิสต์ เมท็อดจะทำให้เกิดข้อผิดพลาด `IndexError` เช่น
```
>>> accountant_list.pop(10)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
IndexError: pop index out of range
```
ในกรณีที่ไม่มีการระบุดัชนี เมท็อด `.pop()` จะนำสมาชิกตัวสุดท้ายออกจากลิสต์

## ดิกชันนารี (Dictionary)
ดิกชันนารี หรือที่โปรแกรมเมอร์มักเรียกย่อว่า "ดิกต์ (dict)" เป็นโครงสร้างข้อมูลที่ใช้เก็บคู่ของคีย์ (key) และแวลู (value) โดยคีย์และแวลูสามารถเป็นข้อมูลประเภทใดก็ได้ ดิกชันนารีมีการทำงานคล้ายคลึงกับพจนานุกรมที่เราคุ้นเคย ซึ่งคีย์เปรียบเสมือนคำที่เราต้องการค้นหา และแวลูเปรียบเสมือนความหมายของคำนั้น ๆ อย่างไรก็ตาม ดิกชันนารีในภาษาไพทอนสามารถมีคีย์และแวลูเป็นข้อมูลประเภทใดก็ได้ ไม่จำกัดแค่คำศัพท์และความหมายเหมือนพจนานุกรม

อีกประการหนึ่งที่ดิกชันนารีในวิทยาการคอมพิวเตอร์มีความคล้ายคลึงกับพจนานุกรม คือ ดิกชันนารีถูกใช้เพื่อตอบคำถามว่า *คีย์นี้มีคู่กับแวลูอะไร* แต่ไม่สามารถตอบคำถามในทิศทางตรงกันข้ามได้ว่า *แวลูนี้คู่กับคีย์อะไร* ในการใช้งานดิกชันนารี เราสามารถค้นหาว่าคีย์ที่ได้รับมานั้นจับคู่กับแวลูใดได้อย่างรวดเร็ว แต่ไม่สามารถใช้แวลูเพื่อค้นหาคีย์ได้โดยตรง


ตัวอย่างการใช้ดิกชันนารีในการเก็บข้อมูล ได้แก่

| การใช้งาน 	         			| คีย์ | แวลู | 
|----------------------|----|--------|
| สมุดโทรศัพท์			| ชื่อ | เบอร์โทรศัพท์ |
| พจนานุกรมไทย-อังกฤษ	| คำศัพท์ภาษาไทย | ความหมายเป็นภาษาอังกฤษ | 
| ทะเบียนนิสิต				| รหัสประจำตัวนิสิต | รายวิชาที่ลงทะเบียน | 
| ดัชนีท้ายเล่มหนังสือ		| คำสำคัญ | เลขหน้าที่มีคำนั้นปรากฏอยู่ | 
| ระบบค้นหา (search engine)		| คำ | หมายเลขของเอกสารที่มีคำนั้นอยู่  | 
| สถิติของคำในคลังข้อมูล		|  คำ  | จำนวนครั้งที่พบเจอคำนั้นในคลังข้อมูล | 

จากตัวอย่างแรกหากเราจัดเก็บสมุดโทรศัพท์ โดยให้คีย์เป็นชื่อแวลูเป็นเบอร์โทรศัพท์ เราจะไม่สามารถเปิดหาได้ว่าเบอร์ปริศนาที่ได้มานั้นเป็นเบอร์ของใคร 

ดิกชันนารีถูกออกแบบมาเพื่อค้นหาแวลูจากคีย์ได้อย่างรวดเร็ว การค้นหาแวลูโดยใช้คีย์สามารถทำได้ในระยะเวลาคงที่ (constant time) โดยไม่ขึ้นกับจำนวนคู่คีย์แวลูที่เก็บอยู่ในดิกชันนารี ตัวอย่างเช่น หากเราต้องการค้นหาเบอร์โทรศัพท์ของคนหนึ่งในสมุดโทรศัพท์ที่เก็บในดิกชันนารี เราสามารถใช้คีย์ซึ่งเป็นชื่อของบุคคลนั้นเพื่อดึงแวลูที่เป็นหมายเลขโทรศัพท์ได้ทันที โดยไม่ต้องคำนึงถึงจำนวนข้อมูลที่เก็บอยู่

อย่างไรก็ตาม ดิกชันนารีไม่สามารถทำงานในทิศทางตรงกันข้ามได้ กล่าวคือ เราไม่สามารถค้นหาคีย์จากแวลูได้โดยตรง นั่นหมายความว่า เราไม่สามารถใช้หมายเลขโทรศัพท์เพื่อค้นหาชื่อเจ้าของหมายเลขได้ในดิกชันนารี หากต้องการค้นหาในทิศทางนี้เราจะต้องดึงเอาข้อมูลทั้งหมดจากดิกชันนารีและใช้วงวนฟอร์ในการตรวจสอบสมาชิกทุกตัวในดิกชันนารี ซึ่งเป็นอัลกอริทึมที่ใช้เวลาแบบเชิงเส้น (linear time) กล่าวคือระยะเวลาที่ใช้ขึ้นอยู่กับจำนวนคู่คีย์แวลูที่เก็บอยู่ในดิกชันนารี

### การสร้างดิกชันนารีด้วย `{}`
ดิกชันนารีถูกสร้างได้ด้วยการใช้ `{}` 

```python
my_first_dict = {}
```
ตัวแปร `my_first_dict` เป็นดิกชันนารีเปล่าที่ไม่มีข้อมูลเก็บอยู่เลย

เราสามารถใช้ `{}` คร่อมข้อมูลคู่คีย์แวลูที่ต้องการเก็บได้โดยตรง โดยใช้รูปแบบดังนี้

```python
ชื่อตัวแปร = {key1: value1, key2: value2, key3: value3, ..., keyn: valuen}
```
ในรูปแบบนี้ คีย์และแวลูจะถูกจับคู่กันโดยใช้เครื่องหมายโคลอน `:` และแต่ละคู่คีย์แวลูจะถูกคั่นด้วยเครื่องหมายจุลภาค `,` เช่นเดียวกับการสร้างลิสต์ที่ใช้ `,` ในการคั่นสมาชิกแต่ละตัว

```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999', 
			 'เจนนี่': '011-111-1111'}
```

ดิกชันนารีนี้เก็บข้อมูลเกี่ยวกับชื่อและหมายเลขโทรศัพท์ในลักษณะของคู่คีย์และแวลู ดังนี้

|คีย์|แวลู|
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|

### ชื่อตัวแปรที่เก็บดิกชันนารี
ชื่อตัวแปรที่ใช้เก็บดิกชันนารีควรบ่งบอกให้ชัดเจนว่าคีย์และแวลูคืออะไร และคั่นด้วย `_to_` เพื่อเป็นการบ่งบอกว่าตัวแปรเก็บดิกชันนารีอยู่  เช่น
- `name_to_phone_number` เก็บชื่อเป็นคีย์ และเบอร์โทรศัพท์เป็นแวลู
- `word_to_frequency` เก็บคำเป็นคีย์ และจำนวนครั้งที่พบเป็นแวลู
- `student_id_to_name` เก็บรหัสนักศึกษาเป็นคีย์ และชื่อเป็นแวลู 

แม้ว่าชื่อตัวแปรจะไม่มีผลต่อการทำงานของโปรแกรม แต่การตั้งชื่อตัวแปรที่สื่อความหมายชัดเจนจะช่วยให้โค้ดอ่านง่ายและเข้าใจง่ายมากยิ่งขึ้น โดยเฉพาะเมื่อใช้ดิกชันนารีซึ่งเป็นโครงสร้างข้อมูลที่อาจซับซ้อน

### หาจำนวนคู่คีย์แวลูด้วยคำสั่ง `len`

คำสั่ง `len` เมื่อใช้กับดิกชันนารีจะ คืนค่าจำนวนคู่ของคีย์แวลูที่อยู่ในดิก

```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
len(name_to_phone_number) #--> 3
```
ในตัวอย่างนี้ ดิกชันนารี `name_to_phone_number` มีคู่คีย์-แวลูทั้งหมด 3 คู่ ดังนั้น `len(name_to_phone_number)` จะคืนค่า 3

### เพิ่มข้อมูล (คู่ key-value) เข้าดิกชันนารี
เมื่อเราสร้างดิกชันนารีขึ้นมาแล้วอันหนึ่ง เราสามารถเพิ่มคู่คีย์แวลูได้ด้วยคำสั่ง `d[key] = value` โดยคีย์จะเป็นสตริง หรือตัวเลขก็ได้ แต่ไม่สามารถใช้บูลีน หรือลิสต์มาเป็นคีย์ได้ เช่น 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
```
บรรทัดแรกเราสร้างดิกชันนารรีที่เก็บค่าคีย์แวลู ดังนี้

|คีย์|แวลู|
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|

หลังจากรันบรรทัดที่ 2 ข้อมูลในดิกชันนารีจะกลายเป็น

|คีย์|แวลู|
|-----|-------|
|'ตังเม'| '088-888-8888'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|
|'โนโซมิ'|  '066-666-6666' |

ข้อควรระวัง คือคีย์ในดิกชันนารีต้องไม่ซ้ำกัน หากพยายามเพิ่มคู่คีย์-แวลูที่มีคีย์ซ้ำกับคีย์ที่มีอยู่แล้วในดิกชันนารี ข้อมูลเดิมจะถูกเขียนทับ เช่น 

```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
name_to_phone_number['ตังเม'] = '011-222-3333'
```
หลังจากรันโค้ดนี้แล้ว ข้อมูลในดิกชันนารีจะเปลี่ยนไปเป็นดังนี้ 

|คีย์|แวลู|
|-----|-------|
|'ตังเม'| '011-222-3333'|
|'เป่าหลง'| '099-999-9999'|
|'เจนนี่'| '011-111-1111'|
|'โนโซมิ'|  '066-666-6666' |

ดิกชันนารีมีคีย์แวลู อยู่ 4 คู่ เท่าเดิม  `name_to_phone_number['ตังเม'] = '011-222-3333'` เปลี่ยนคู่คีย์แวลู ที่มี `'ตังเม'` เป็นคีย์ให้เป็นค่าใหม่ที่ป้อนเข้าไป  ให้สังเกตด้วยว่าดิกชันนารีไม่ได้ลบคู่คีย์แวลู เก่าและเติมคู่ใหม่เข้าไป ดิกชันนารีจะเขียนทับตำแหน่งเดิม

### เข้าถึงแวลูด้วย key: `[]` และ `.get()`
เราสามารถระบุคีย์ที่เราต้องการทราบแวลูได้ สมมติว่าเราต้องการทราบเบอร์โทรศัพท์ของตังเม จากดิกชันนารีที่เก็บหมายเลขโทรศัพท์ 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['ตังเม'] # ---> '088-888-8888'
```
การเปิดหาแวลูจากคีย์ที่ระบุเราเรียกว่าการเปิดหาข้อมูลในดิกชันนารี (dictionary lookup) ซึ่งแปลว่าเครื่องเก็บข้อมูลทุกอย่างไว้ในดิกชันนารีแล้ว ไม่ต้องไปตามมาหามาจากแหล่งอื่น สามารถเปิดหาแล้วเจอได้เลย 

ข้อควรระวังคือ ถ้าหากว่าเรา lookup จากคีย์ที่ไม่ได้มีอยู่ในดิกชันนารีเราจะได้ `KeyError` คืนกลับมา
```
>>> name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999', 
...                      'เจนนี่': '011-111-1111'}
>>> name_to_phone_number['โนโซมิ']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'โนโซมิ'
```

ข้อควรระวังอีกประการคือ เราไม่สามารถ lookup จากแวลูเพื่อหาคีย์ได้ เนื่องจากดิกชันนารีเก็บข้อมูลในลักษณะเราไปจากคีย์ไปสู่แวลูได้ แต่ทำกลับกันไม่ได้ เครื่องจะให้ `KeyError` กลับมา
```
>>> name_to_phone_number['011-111-1111']
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: '011-111-1111'
```

เพื่อป้องกันการเกิด `KeyError` เราสามารถใช้ `.get()` เพื่อ lookup แต่กำหนดค่าสำรองที่จะ คืนค่าได้ในกรณีที่คีย์นั้นไม่มีอยู่ในดิก
```
>>> word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
>>> word_to_freq['Jack']
KeyError: 'Jack'
>>> word_to_freq.get('Jack')
None
>>> word_to_freq.get('Jack', 0)
0
```
บรรทัดที่สองคือการเปิดหาคีย์`'laptop'` ในดิกชันนารี แต่ถ้าหากไม่เจอให้ คืนค่า0 ทำให้เราไม่ต้องเจอกับ `KeyError` 

### `for` ลูปบนดิกชันนารี
เราสามารถ for ลูปวนซ้ำไปบนคีย์(iterate on keys) วนซ้ำไปบนแวลู(iterate on values) หรือวนซ้ำไปบนคู่คีย์แวลู(iterate on key-value pairs) ขึ้นอยู่กับการใช้งาน โดยเราจะใช้เมท็อด`.keys() .values() .items()` ตามลำดับ ทั้ง 3เมท็อดนี้จะ คืนค่าค่าที่มี type เป็น *iterable* ซึ่งก็คือสิ่งที่เราสามารถ iterate ไปได้  

#### วนซ้ำไปบนคีย์
เราสามารถใช้ไวยากรณ์ของ `for` ลูปไปบนดิกชันนารี ซึ่งจะตีความไปว่าเราจะไล่เรียงไปบนคีย์แต่ละตัว 
ตั้งแต่ Python 3.7 ขึ้นไป การลูปบนดิกชันนารี เครื่องจะไล่เรียงข้อมูล ออกมาจะเป็นลำดับเดียวกับตอนที่ใส่ข้อมูลเข้าไป 
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
name_to_phone_number['ตังเม'] = '011-222-3333'
for name in name_to_phone_number: 
	print(name)
```
จะได้ผลออกมาคือ
```python
ตังเม
เป่าหลง
เจนนี่
โนโซมิ
```
สังเกตว่า `ตังเม` ถูกไล่เรียงออกมาเป็นอันดับแรก ถึงแม้ว่าจะถูกเขียนทับทีหลังก็ตาม โดยทั่วไปแล้วเราไม่ควรอาศัยให้ดิกชันนารีเรียงลำดับข้อมูลตามลำดับที่ข้อมูลถูกป้อนเข้าไป 

หรือถ้าหากให้โค้ดมีความกระจ่างขึ้นว่าเรากำลังวนซ้ำไปบนคีย์สามารถใช้เมท็อด`.keys()` เช่น
```python
for name in name_to_phone_number.keys(): 
	print(name)
```

แต่ถ้าหากต้องการเก็บคีย์ทั้งหมดไว้ในลิสต์แยกออกมาให้ใช้คำสั่ง `list()` เป็นการแปลง type จาก iterable ให้เป็นลิสต์ดังนี้

```
name_list = list(name_to_phone_number.keys())
```

#### วนซ้ำไปบน value
ดิกชันนารีมีเมท็อด`.values()` ที่ทำให้เราวนซ้ำไปบนแวลูได้
```python
name_to_phone_number = {'ตังเม': '088-888-8888', 'เป่าหลง' : '099-999-9999',
	'เจนนี่': '011-111-1111'}
name_to_phone_number['โนโซมิ'] = '066-666-6666'
for number in name_to_phone_number.values():
	print(number)
```
จะได้ผลออกมาคือ
```
088-888-8888
099-999-9999
011-111-1111
066-666-6666
```
ลำดับที่ปรากฎเหมือนกันกับการวนซ้ำไปบนคีย์

เมท็อด`.values()` ให้ค่าเป็น iterable เช่นกัน เพราะฉะนั้นเราสามารถเก็บเอาแวลูทั้งหมดใส่ลิสต์โดยการแปลง type ให้เป็นลิสต์ด้วยคำสั่ง `list()`

```
phone_numbers = list(name_to_phone_number.values())
```

#### วนซ้ำไปบนคู่ key-value

```python
for name, number in name_to_phone_number.items():
	print(name)
	print(number)
```
จะได้ผลออกมาคือ
```
ตังเม
088-888-8888
เป่าหลง
099-999-9999
เจนนี่
011-111-1111
โนโซมิ
066-666-6666
```

### ตรวจสอบว่ามีคีย์นั้นอยู่ในดิกชันนารีหรือไม่: `in`
เราสามารถตรวจสอบว่าคีย์ที่เราต้องการหามีอยู่ในดิกชันนารีอยู่แล้วหรือไม่ 

```python
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
'Jack' in word_to_freq #---> False
```

การตรวจสอบว่าแวลูอยู่ในดิกชันนารีหรือไม่ทำได้ค่อนข้างลำบากเราจะต้อง `for` ลูปวนไปบนแวลูทั้งหมดเพื่อหาเอง  เช่น ถ้าเราอยากทราบว่าค่า `200` เป็นแวลูที่อยู่ในดิกชันนารีหรือไม่ 
```python
value_to_find = 200
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
for freq in word_to_freq.values():
	if value_to_find == freq:
		คืนค่าTrue
คืนค่าFalse
```
หรือนำแวลูเข้าลิสต์ก่อนแล้วค่อยใช้ `in` ในการตรวจสอบ
```python
value_to_find = 200
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
freq_list = list(word_to_freq.values())
คืนค่าvalue_to_find in freq_list
```
ซึ่งทั้งสองวิธีเป็นมักจะใช้เวลานานเนื่องจากเราจะต้องวนไล่ไปบนแวลูแต่ละตัว ยิ่งดิกชันนารีใหญ่แค่ไหนเวลาในการรันโปรแกรมก็จะนานตามไปด้วย ซึ่งต่างจากการตรวจสอบคีย์ซึ่งใช้เวลาในการรันโปรแกรมเป็นค่าคงตัว ไม่ขึ้นกับขนาดของดิกชันนารี ถ้าหากเราจำเป็นต้องมีการตรวจสอบว่ามีแวลูอะไรอยู่หรือไม่ เราไม่ควรใช้ดิกชันนารีในการ

### ลบคู่ key-value: `.pop`
เราสามารถลบคู่คีย์แวลูโดยการระบุคีย์ไม่สามารถลบโดยการระบุแวลูได้
```python
word_to_freq = {'the': 50000, 'jump' : 200, 'Andy': 80}
word_to_freq.pop('the')
print(word_to_freq)
```
จะได้ผลออกมาคือ
```python
{'jump': 200, 'Andy': 80}
```


## ทูเปิล (tuple) 
ทูเปิล เป็นโครงสร้างข้อมูลที่เก็บข้อมูลเป็นลำดับคล้ายกับลิสต์ ลิสต์สามารถทำทุกอย่างที่ทูเปิลสามารถทำได้ การสร้างทูเปิลคล้ายคลึงกับการสร้างลิสต์แต่ว่าเราจะใช้วงเล็บ `()` แทนวงเล็บเหลี่ยม `[]` เช่น
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
```

ข้อแตกต่างคือ ทูเปิลเป็นโครงสร้างข้อมูลที่เปลี่ยนแปลงไม่ได้ (immutable) เมื่อเราสร้างทูเปิลขึ้นมาแล้ว ไม่สามารถเปลี่ยนแปลงสมาชิกที่อยู่ภายในได้ รวมถึงไม่สามารถเพิ่มสมาชิกเข้าไปได้ ทั้งหมดนี้ดูเหมือนจะเป็นข้อเสียของทูเปิล แต่ว่าการใช้ทูเปิลทำให้เกิดข้อผิดพลาดในโปรแกรมน้อยลง 
การใช้ทูเปิลเป็นการสื่อความหมายในโปรแกรมว่าแต่ละดัชนีของทูเปิลมีความหมายเจาะจง เช่น

- พิกัดบนแผนที่โลก อาจจะถูกเก็บในทูเปิดโดยที่ดัชนี0 เป็น latitude และดัชนี1 เป็น longtitude อาจจะถูกเก็บในทูเปิล ดังนี้  `('13.7563° N', '100.5018°')`
- ชื่อนามสกุล อาจจะถูกเก็บในทูเปิลโดยที่ดัชนี0 เป็นชื่อดัชนี1 เป็นนามสกุล ดังนี้ `('อรรถพล', 'ธำรงรัตนฤทธิ์')`
- สี มักจะถูกจัดเก็บเป็นค่าแดงเขียวน้ำเงิน (RGB) โดยที่ดัชนี0 เป็นค่าของสีแดงดัชนี1 เป็นค่าของสีเขียวดัชนี2 เป็นค่าของสีน้ำเงิน ดังนี้ `(256, 256, 256)`

ในกรณีดังกล่าวทั้งหมดนี้เราไม่ควรจะเพิ่มสมาชิกเข้าไปในทูเปิลอีกแล้ว เพราะว่าพิกัดจะต้องมี 2 ตำแหน่งเท่านั้น ชื่อนามสกุลควรจะต้องถูกแทนด้วยทูเปิลแบบสองตำแหน่ง ค่าสีแบบ RGB ก็ต้องมีสีสามค่าเท่านั้น การเพิ่มสมาชิกเข้าไปทำให้สูญเสียความหมายของสิ่งที่ทูเปิลจะเก็บไว้

การเข้าถึงข้อมูลในทูเปิลใช้วิธีเดียวกับลิสต์ทุกประการ สามารถใช้ positiveดัชนีและ negativeดัชนีได้เหมือนกันหมด 
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
first_name = first_last_name[0]
last_name = first_last_name[1]
print (first_name)
print (last_name)
```
เพื่อความสะดวกเรามักจะ*กระจาย*ค่าของทูเปิลใส่ตัวแปรหลาย ๆ ตัวพร้อม ๆ กัน เช่น 
```python
first_last_name = ('อรรถพล', 'ธำรงรัตนฤทธิ์')
first_name, last_name = first_last_name
print (first_name)
print (last_name)
```
การกระจายค่าที่จริงแล้วสามารถทำกับลิสต์ก็ได้ แต่ว่าไม่กรณีที่จะให้ใช้เนื่องจากเวลาเราเขียนโค้ดในการกระจายค่าเข้าสู่ตัวแปร เราจำเป็นต้องรู้ว่าลิสต์หรือทูเปิลนั้นมีจำนวนสมาชิกกี่ตัว ลิสต์เป็นโครงสร้างข้อมูลที่เราสามารถเปลี่ยนแปลงค่าข้างในได้ ทำให้เราไม่แน่ใจว่าข้อมูลในลิสต์มีอยู่กี่ตัว เมื่อเรามาถึงส่วนของโค้ดที่ต้องทำการกระจายข้อมูล แต่ว่าทูเปิลไม่มีปัญหานี้ เวลาเราสร้างทูเปิล เรามั่นใจได้เลยว่าค่าของทูเปิล และจำนวนสมาชิกของทูเปิลจะไม่เปลี่ยน 

ทูเปิลมีเมท็อด`.count .index` เช่นเดียวกับลิสต์ และสามารถหั่นเป็นทูเปิลย่อยได้เหมือนกับลิสต์เช่นกัน แต่ว่ามักจะไม่ค่อยได้ใช้ประโยชน์ เพราะทูเปิลมีโครงสร้างตายตัว และข้อมูลที่อยู่ในแต่ละตำแหน่งเก็บข้อมูลคนละชนิดกันหมด 

## เคาน์เตอร์ (counter)
เคาน์เตอร์ เป็น*ซับคลาส (subclass)* ของดิกชันนารี ซึ่งแปลว่าเคานเตอร์สามารถทำได้เกือบทุกอย่างที่ดิกชันนารีสามารถทำได้ และยังมีเมท็อดอื่น ๆ เพิ่มเติม 

เคาน์เตอร์เป็นดิกชันนารีที่คีย์เป็นอะไรก็ได้ แต่ว่าแวลูจะต้องเป็นตัวเลข เท่านั้น จุดประสงค์หลักของการใช้โครงสร้างข้อมูลชนิดนี้คือเพื่อเก็บจำนวนครั้งที่พบคีย์แต่ละอัน 

เคาน์เตอร์ไม่ใช่ *บิวท์อินคลาส (built-in class)* ก่อนจะใช้จะต้อง `import` เข้ามาก่อนที่จะเรียกใช้ เคาน์เตอร์เป็นคลาสที่เป็นส่วนหนึ่งของโมดูล `collections` 

### การสร้างเคาน์เตอร์ว่าง ๆ
ใช้คำสั่ง `Counter()` ในการสร้างเคาน์เตอร์ซึ่งเป็นคำสั่งที่ต้อง `import` เข้ามาก่อน
```python
from collections import Counter
word_count = Counter()
```
### การสร้างเคาน์เตอร์จากดิกชันนารี
เราสร้างแปลงดิกชันนารีที่แวลูเป็นตัวเลขมาเป็นเคาน์เตอร์ได้ดังนี้
```python
word_count = Counter({'b':1, 'a':3, 'c':1})
```

### การสร้างเคาน์เตอร์จากลิสต์
การสร้างเคาน์เตอร์ คือ การใช้เคาน์เตอร์สามารถนับค่าต่าง ๆ ที่เก็บอยู่ในลิสต์ และจัดเก็บให้ค่าทั้งหมดเป็นคีย์และจำนวนครั้งที่พบให้เก็บเป็นแวลู
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count['a'] #--> 3
letter_count['b'] #--> 2
letter_count['c'] #--> 1
```

###คีย์ที่ไม่ได้อยู่ในเคาน์เตอร์แวลูจะเป็น 0
เมื่อเวลาเราเปิดหาค่าคีย์ที่ไม่ได้มีอยู่ในเคาน์เตอร์ค่าที่ได้คืนมาจะเป็น 0 เสมอ ซึ่งต่างจากดิกชันนารีที่จะโยน `KeyError` กลับมา
```python
letter_count['d'] #--> 0
```
ฟีเจอร์นี้ทำให้เราใช้เคาน์เตอร์ได้สะดวกมากขึ้น เมื่อเราต้องการถามว่าค่าอะไรเจอกี่ครั้งบ้าง ถ้าค่าที่ไม่เจอเลยค่าที่ได้กลับคืนมาก็ควรจะเป็น 0 นอกจากนั้นแล้วเราสามารถอัพเดทเคาน์เตอร์ได้โดยไม่จำเป็นต้องตรวจสอบก่อนว่าคีย์นั้นเคยมีอยู่ในเคาน์เตอร์แล้วหรือยัง เช่น สมมติว่าเราต้องการนับแค่คำที่ไม่มีตัวเลขปะปนอยู่เลยที่จัดเก็บอยู่ในลิสต์ `word_list`
```python
word_counter = Counter()
for word in word_list:
    if word.isalpha():
        word_counter[word] = word_counter[word] + 1
```
`word_counter[word]` ค่าเป็น 0 ถ้าเราไม่เคยเห็นคำนั้นมาก่อนซึ่งทำให้ expression ทางขวามือของเครื่องหมายเท่ากับเป็น `0 + 1` ซ่ึงเป็นผลที่เราต้องการ 
ถ้าหากเราจะใช้ดิกชันนารีก็สามารถทำได้ 
```python
word_counter = {}
for word in word_list:
    if word.isalpha():
        if word not in word_counter:
            word_counter[word] = 0
        word_counter[word] = word_counter[word] + 1
```
แต่เราต้องตรวจสอบว่าคีย์อยู่ในดิกอยู่แล้วหรือไม่ ถ้าไม่ได้อยู่ต้องทำการตั้งคู่คีย์แวลูใหม่โดยตั้งให้ค่าแวลูเป็น 0 เตรียมเอาไว้ก่อน เพื่อป้องกัน `KeyError` 

### หาค่าคีย์ที่คู่กับแวลูที่สูงที่สุด: `.most_common()`
เคาน์เตอร์มีเมท็อดที่ไว้สำหรับคีย์ที่พบบ่อยที่สุด 
```python
letter_list = ['a', 'b', 'c', 'a','b', 'a']
letter_count = Counter(letter_list)
letter_count.most_common() #--> [('a', 3), ('b', 2), ('c', 1)]
letter_count.most_common(1) #--> [('a', 3)]
```
เมท็อดนี้มี optional parameter ที่เราจะระบุหรือไม่ระบุก็ได้ว่าจะ คืนค่าผลกี่อันดับแรก ถ้าไม่ระบุจะให้ผลอย่างมาก 20 อันดับแรก สิ่งที่เมท็อดคืนค่ามาให้คือลิสต์ของทูเปิล ทูเปิลที่ได้มาเป็นคู่ของคีย์แวลูเรียงลำดับตามแวลู

## เซต (Set)

เซต เป็นโครงสร้างข้อมูลที่เก็บข้อมูลที่ไม่ซ้ำกัน และไม่มีลำดับ ซึ่งล้อกับเซตในคณิตศาสตร์ เซตมีความคล้ายคลึงกับลิสต์ คือ สามารถเก็บข้อมูล และเรียกใช้ข้อมูลที่เก็บเอาไว้ได้ แต่ข้อแตกต่างที่สำคัญ ได้แก่

1. เซตไม่เก็บลำดับของข้อมูล เพราะฉะนั้นเราไม่สามารถใช้ `[index]` ในการเข้าถึงข้อมูลได้ ไม่สามารถใช้ `[]` ในการหั่นเซตได้ ถึงแม้เราสามารถใช้ `for` ในเพื่อเข้าถึงสมาชิกในเซตได้ แต่ว่าลำดับการไล่สมาชิกแต่ละตัวจะไม่ตรงกับลำดับที่เราเพิ่มสมาชิกเข้าไปในเซต

2. เซตไม่เก็บสมาชิกที่ซ้ำกัน ถ้าเราเพิ่มสมาชิกที่มีอยู่แล้วในเซต สมาชิกที่เพิ่มเข้าไปจะไม่ถูกเก็บ และเซตจะไม่แสดง error หรือเกิดข้อผิดพลาดใดๆ ขึ้น

3. การตรวจสอบว่าสมาชิกอยู่ในเซตหรือไม่ ทำได้เร็วกว่าการตรวจสอบในลิสต์ เนื่องจากเซตไม่เก็บลำดับข้อมูล ทำให้อัลกอริทึมในการตรวจสอบการเป็นสมาชิกดำเนินไปได้อย่างรวดเร็ว 

### การสร้างเซต และการหาขนาดของเซต

เซตถูกสร้างขึ้นได้โดยการใช้ `{}` หรือคำสั่ง `set()` ถ้าต้องการสร้างเซตว่าง สามารถใช้ `{}` หรือคำสั่ง `set()` ได้เลย ดังตัวอย่างต่อไปนี้

```python
basket = {}
basket = set()
```

หากต้องการสร้างเซตแบบเป็นค่าคงที่ (literal) กล่าวคือสมาชิกของลิสต์ถูกระบุเอาไว้โดยตรงในโค้ด 
เราสามารถใช้ `{}` ในการสร้างเซต และใส่สมาชิกที่ต้องการเก็บในเซตลงไปใน `{}` ซึ่งสมาชิกแต่ละตัวจะต้องคั่นด้วย `,` และสมาชิกที่ซ้ำกันจะถูกเก็บเพียงตัวเดียว ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```

หากใช้คำสั่ง `set` ในการสร้างเซต จะต้องใส่ลิสต์หรือสตริงที่ต้องการเก็บในเซตลงไปใน `set()` ดังตัวอย่างต่อไปนี้

```python
basket = set(['apple', 'orange', 'apple', 'orange', 'banana'])
basket # เก็บแค่ {'orange', 'banana', 'apple'}
```
เพราะฉะนั้นเราสามารถใช้เซตในการเปลี่ยนสมาชิกในลิสต์ให้เหลือแต่สมาชิกที่ไม่ซ้ำกันได้ โดยการเปลี่ยนลิสต์ให้เป็นเซตด้วยคำสั่ง `set` และนำผลลัพท์ที่ได้เปลี่ยนกลับให้เป็นลิสต์ด้วยคำสั่ง `list` ดังตัวอย่างต่อไปนี้

```python
fruits = ['apple', 'orange', 'apple', 'orange', 'banana']
fruit_set = set(fruits)
fruit_list_no_duplicate = list(fruit_set)
```

วิธีการหาขนาดของเซต (หรือจำนวนสมาชิกของเซต) คล้ายคลึงกับการหาขนาดของลิสต์ และการหาขนาดของดิกชันนารี เราใช้ `len()` ในการหาขนาดของเซตได้ ดังตัวอย่างต่อไปนี้

```python
basket = {'apple', 'orange', 'apple', 'orange', 'banana'}
len(basket) # 3
```

### การสร้างเซตด้วย set comprehension
set comprehension คือ วิธีการสร้างเซตที่ใช้คำสั่งแบบกระชับ และสร้างเซตขึ้นมาโดยใช้เวลาน้อยกว่าการสร้างเซตโดยวิธีอื่น ๆ   set comprehension คล้ายคลึงกับ list comprehension ตรงที่เราเริ่มจากแปลงข้อมูลจากลิสต์ ดิกชันนารี หรือเซตอื่นๆ ให้กลายเป็นเซต (แทนที่จะเป็นลิสต์) 

โครงสร้างของการสร้างเซตด้วย set comprehension คล้ายกับ list comprehension เพียงแต่เราเปลี่ยน `[]` เป็น `{}` แทน ดังนี้
```python
{นิพจน์ (expression) for ไอเท็ม in ลิสต์ เซต หรือดิกชันนารี if เงื่อนไข}
```
- นิพจน์ (expression) คือสูตรหรือคำสั่งที่ใช้แปลงไอเท็มแต่ละไอเท็มในลิสต์ เซต หรือดิกชันนารี ให้กลายเป็นสมาชิกของเซตที่เรากำลังสร้างขึ้น
- เงื่อนไขการเข้าสู่เซต (มีหรือไม่มีก็ได้) เป็นสูตรที่แปลงไอเท็มให้เป็นบูลีน ถ้าบูลีนเป็น `True` ไอเท็มจะถูกเพิ่มเข้าไปในเซตที่กำลังสร้างขึ้น แต่ถ้าบูลีนเป็น `False` ไอเท็มจะไม่ถูกเพิ่มเข้าไปในเซตที่กำลังสร้างขึ้น

สมมติว่าเราต้องการสร้างเซตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน
```python
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {name for name in student_names if name.endswith('า')}
```
เราสามารถใช้ set comprehension ในการสร้างเซตของชื่อนักเรียนที่ลงท้ายด้วยสระอาได้ด้วยคำสั่งบรรทัดเดียว โครงสร้างของคำสั่ง set comprehension แบ่งเป็นสามส่วนดังนี้
- expression ไม่มีการเปลี่ยนแปลงชื่อนักเรียน แต่เราใช้ `name` ในการเข้าถึงชื่อนักเรียนแต่ละคน
- ไอเท็มเป็นชื่อที่ได้จากการใช้ `for` ในการวนลูปเพื่อเข้าถึงชื่อนักเรียนทุกคนในลิสต์ `student_names`
- เงื่อนไขการเข้าสู่เซต เราใช้ `name.endswith('า')` ในการตรวจสอบว่าชื่อนักเรียนลงท้ายด้วยสระอาหรือไม่ ถ้าลงท้ายด้วยสระอา ชื่อนักเรียนจะถูกเพิ่มเข้าไปในเซตที่กำลังสร้างขึ้น แต่ถ้าไม่ลงท้ายด้วยสระอา ชื่อนักเรียนจะไม่ถูกเพิ่มเข้าไปในเซตที่กำลังสร้างขึ้น

### การตรวจสอบการเป็นสมาชิกโดยใช้ `in`
เราสามารถตรวจสอบว่าข้อมูลที่ได้มาเป็นสมาชิกของเซตหรือไม่ โดยใช้ `in` ได้ ดังตัวอย่างต่อไปนี้

```python
languages = {'French', 'English', 'German', 'Chinese'}
'English' in languages # True
'Thai' in languages # False
```

เซตสละความสามารถในการเก็บลำดับของข้อมูล เพื่อแลกมากับความเร็วในการหาข้อมูล (lookup) ในเซต อัลกอริทึมหลังบ้านของ operator `in` ของลิสต์จะต้องไล่สมาชิกทีละตัว จนกว่าจะเจอสมาชิกที่ต้องการ หรือจนกว่าจะไล่สมาชิกทุกตัวแล้ว ซึ่งในกรณีที่สมาชิกมีจำนวนมาก ในทางตรงกันข้ามอัลกอริทึมหลังบ้านของ operator `in` ใช้อัลกอริทึมที่เรียกว่าแฮชชิง (hashing) ซึ่งใช้เวลาคงที่ ไม่ขึ้นกับจำนวนของสมาชิกที่อยู่ในเซต  ทำให้เซตเป็นโครงสร้างข้อมูลที่เหมาะสมกับการตรวจสอบการเป็นสมาชิกกว่าลิสต์

### for loop ในเซต
เราสามารถใช้ `for` ในการวนลูปเพื่อเข้าถึงสมาชิกทุกตัวในเซตได้ เหมือนกับการทำ `for` บนลิสต์ แต่เมื่อเซตไม่มีการเก็บลำดับของสมาชิกไว้ การไล่ด้วย `for` จึงไม่ได้ไล่ไปตามลำดับของสมาชิกว่าตัวไหนถูกใส่เข้ามาก่อน ใส่เข้ามาทีหลัง 
```python
languages = {'French', 'English', 'German'}
for language in languages:
    print(language)
```
ผลลัพธ์ที่ print ออกมาคือ
```
German
English
French
```
ถึงแม้ผลลัพธ์ออกมาจะดูเหมือนว่าเซตเก็บข้อมูลโดยเรียงลำดับตามพจนานุกรม แต่ว่าเราไม่สามารถการันตีได้ว่าจะได้ลำดับตามพจนานุกรมเสมอไป เพราะโดยคำนิยามแล้วสมาชิกในเซตไม่มีการจัดลำดับใด ๆ ทั้งสิ้น ไพทอนเวอร์ชันต่อไปอาจจะไม่ได้แสดงผลลัพธ์ออกมาเรียงลำดับตามพจนานุกรมอย่างที่เห็นในเวอร์ชันนี้ (3.11) ก็เป็นได้

### การเพิ่มสมาชิกในเซตด้วย `add()` 
เราสามารถเพิ่มสมาชิกในเซตได้โดยใช้คำสั่ง `add` ซึ่งต่างจากคำสั่ง `append` ของลิสต์ คำว่า append ภาษาอังกฤษแปลว่าเพิ่มไปตรงท้าย แต่คำว่า add แปลว่าเพิ่มเข้าไปโดยไม่ได้คำนึงถึงลำดับของสมาชิก ผู้พัฒนาภาษาไพทอนเลือกใช้คำว่า add เพื่อแสดงให้เห็นว่าเซตไม่เก็บลำดับของสมาชิก 

#### ตัวอย่าง
สมมติว่าเราทำโจทย์เดียวกับตัวอย่างที่ผ่านมา เราต้องการสร้างเซตของชื่อนักเรียนที่ลงท้ายด้วยสระอาจากลิสต์รายชื่อนักเรียน เราสามารถใช้คำสั่ง `add` เพื่อเพิ่มสมาชิกที่ต้องการเข้าไปทีละตัว แทนที่การใช้ set comprehension ได้ดังนี้

```python 
student_names = ['อาทิตยา', 'วิภา', 'อรรถพล', 'วิภา', 'คริส', 'สุชาดา']
aa_name_set = {} # จะใช้ aa_name_set = set() แทนก็ได้
for name in student_names:
    if name.endswith('า'):
        aa_name_set.add(name)
```

### เอาสมาชิกออกจากเซตด้วย `remove()`
คำสั่งนี้อาจจะเป็นคำสั่งที่ใช้ไม่ได้บ่อยนัก แต่เราควรรู้ไว้เพื่อความสมบูรณ์ของเนื้อหา คำสั่ง `remove` ใช้ในการลบสมาชิกออกจากเซต โดยเราต้องระบุสมาชิกที่ต้องการลบออกไป ดังตัวอย่างต่อไปนี้

#### ตัวอย่าง
สมมติว่ามีคำตอบในแบบสอบที่มีตัวเลือก 5 ตัวเลือก คือ Strongly disagree, Disagree, Neutral, Agree, Strongly agree และเราต้องการลบตัวเลือก Strongly disagree และ Strongly agree ออกจากเซตของตัวเลือกที่เป็นไปได้

```python
possible_responses = {'Strongly disagree', 'Disagree', 'Neutral', 'Agree', 'Strongly agree'}
possible_responses.remove('Strongly disagree')
possible_responses.remove('Strongly agree')
```

### Set operation: intersection union และการลบกันของเซต
เซตในภาษาไพทอนรองรับ set operation ทุกตัว สมมติว่าเรามีเซต A เก็บอยู่ในตัวแปร `setA` และเซต B เก็บอยู่ในตัวแปร `setB`

- intersection (A ∩ B) คือ การสร้างเซตที่ประกอบด้วยสมาชิกที่อยู่ทั้งในเซต A และเซต B ภาษาไพทอนใช้คำสั่ง `setA.intersection(setB)`
- union (A ∪ B) คือ การสร้างเซตที่ประกอบด้วยสมาชิกที่อยู่ในเซต A หรือเซต B อย่างน้อยหนึ่งเซต ภาษาไพทอนใช้คำสั่ง `setA.union(setB)`
- การลบกันของเซต (A - B) คือ การสร้างเซตที่ประกอบด้วยสมาชิกที่อยู่ในเซต A แต่ไม่อยู่ในเซต B ภาษาไพทอนใช้คำสั่ง `setA - setB` หรือ `setA.difference(setB)`

เซตในโลกของการประมวลผลภาษาธรรมชาติมักจะใช้ในการเก็บรายการคำศัพท์ (vocabulary หรือ vocab) เช่น คำศัพท์ที่ปรากฎทั้งหมดในข้อสอบชุดหนึ่ง คำศัพท์ที่เห็นทั้งหมดในคลังข้อมูล (corpus ชุดข้อมูลที่รวบรวมข้อมูลภาษาเอาไว้จำนวนมาก) คำศัพท์ที่แบบจำลองเข้าใจความหมายอยู่แล้ว เซตเหมาะแก่การเก็บ vocabulary เพราะ vocabulary ประกอบด้วยคำศัพท์พบเห็นอย่างน้อยหนึ่งครั้ง โดยไม่คำนึงว่าเกิดขึ้นซ้ำหรือไม่ และไม่คำนึงถึงลำดับการเกิดของคำศัพท์ นอกจากนั้นแล้วเซตในภาษาไพทอนยังรองรับการใช้ set operation ได้อย่างสะดวกสบายอีกด้วย 

ตัวอย่างข้างล่างนี้สมมติว่ามี vocabulary ที่ใหญ่มากซึ่งได้มาจากแบบจำลองภาษาขนาดใหญ่ ครอบคลุมหลายภาษาเก็บอยู่ในตัวแปร `multilingual_vocab` และมี vocabulary ที่มาจากแบบจำลองของภาษาไทยภาษาเดียว เก็บอยู่ในตัวแปร `thai_vocab` 

#### ตัวอย่าง: intersection
สมมติว่าเราต้องการหาว่าคำศัพท์คำใดบ้างที่ปรากฎในทั้งสองเซต คือ `multilingual_vocab` และ `thai_vocab` สามารถใช้คำสั่ง `intersection` ในการหาคำศัพท์ที่ปรากฎในทั้งสองตัวแปรได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฎอยู่ในตัวแปรจะได้ผลดังนี้
```python
print(multilingual_vocab)
```
output ที่ปรากฎบนหน้าจอ คือ
``` {'你好', 'สวัสดี', 'hello'}```

```python
print(thai_vocab)
```
output ที่ปรากฎบนหน้าจอ คือ
``` {'ขอบคุณ', 'สวัสดี'}```
คำสั่ง `intersection` คืนค่าเป็นเซตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `multilingual_vocab` และ `thai_vocab` จะไม่เปลี่ยนแปลง

เพราะฉะนั้นที่ถูกต้องคือ ต้องเก็บค่าที่คืนมาจากคำสั่งไว้ในตัวแปรใหม่ 
```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
overlapping_vocab = multilingual_vocab.intersection(thai_vocab) # {'สวัสดี'}
```
หากเราต้องการทราบจำนวนสมาชิกของแต่ละเซต สามารถใช้ `len()` ในการหาได้ ดังตัวอย่างต่อไปนี้
```python
print(len(multilingual_vocab)) 
print(len(thai_vocab)) 
print(len(overlapping_vocab)) 
```
output ที่จะปรากฎบนหน้าจอ คือ 
```python
4
2
1
```

#### ตัวอย่าง: union
สมมติว่าเราต้องการขยายความสามารถของโมเดลหลากภาษา โดยการขยาย vocabulary ของโมเดลหลากภาษาให้มีคำศัพท์ที่มาจากแบบจำลองภาษาไทยด้วย สามารถใช้คำสั่ง `union` ในการขยาย vocabulary ของโมเดลหลากภาษาได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab) 
print(larger_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฎอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'สวัสดี', 'hello', 'ขอบคุณ', '你好'}
```
คำสั่ง `union` คืนค่าเป็นเซตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection`

ข้อสังเกตอีกอย่างหนึ่งคือ สมาชิกของเซตที่คืนมาจากการใช้คำสั่ง `union` จะไม่เรียงลำดับตามพจนานุกรม หรือเรียงลำดับใด ๆ เลย แต่เราสามารถใช้ `sorted()` ในการเรียงลำดับสมาชิกของเซตได้ ดังตัวอย่างต่อไปนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
larger_vocab = multilingual_vocab.union(thai_vocab)
print(sorted(larger_vocab))
```
output ที่จะปรากฎบนหน้าจอ คือ 
```python
['hello', 'ขอบคุณ', 'สวัสดี', '你好']
```
สังเกตว่าผลที่ได้จะออกมาเป็นลิสต์ ซึ่งเป็นพฤติกรรมที่สมเหตุสมผลของคำสั่ง `sorted` เนื่องจากเราจำเป็นต้องใช้โครงสร้างข้อมูลที่มีการเก็บลำดับของสมาชิกแต่ละตัว 

#### ตัวอย่าง: การลบกันของเซต
สมมติเราต้องการทราบว่า `thai_vocab` มีคำศัพท์ภาษาไทยมากกว่า `multilingual_vocab` กี่คำ สามารถใช้คำสั่ง `difference` ในการหาคำศัพท์ที่มีใน `thai_vocab` แต่ไม่มีใน `multilingual_vocab` ได้ดังนี้

```python
multilingual_vocab = {'hello', 'สวัสดี', '你好', 'สวัสดี', 'สวัสดี', 'สวัสดี'}
thai_vocab = {'สวัสดี', 'ขอบคุณ'}
thai_only_vocab = thai_vocab.difference(multilingual_vocab)
print(thai_only_vocab)
```
หลังจากรันโค้ดแล้วลอง `print` ค่าที่ปรากฎอยู่ในตัวแปรจะได้ผลดังนี้
```python
{'ขอบคุณ'}
```
คำสั่ง `difference` คืนค่าเป็นเซตใหม่ขึ้นมาต่างหาก แยกต่างหากจาก `multilingual_vocab` และ `thai_vocab` ที่เราใช้ในการเรียกคำสั่ง เช่นเดียวกับการใช้คำสั่ง `intersection` และ `union`

### สรุป
เซตในภาษาไพทอนเป็นโครงสร้างข้อมูลที่เหมาะสมกับการเก็บข้อมูลที่ไม่มีการจัดลำดับ และไม่มีการเก็บข้อมูลที่ซ้ำกัน โดยเซตในภาษาไพทอนมีความสามารถในการใช้ set operation ได้ทั้งหมด 3 ตัว คือ intersection union และการลบกันของเซต ในการประมวลผลภาษาธรรมชาติเซตมักถูกใช้ในการเก็บรายการคำศัพท์ หรือเรียกว่า vocabulary 

คำสั่งของเซตในภาษาไพทอน สรุปเป็นตารางได้ดังนี้
| operation | สัญลักษณ์ทางคณิตศาสตร์ | คำสั่งในไพทอน | 
| --- | --- | --- | 
| intersection | A ∩ B | `setA.intersection(setB)` | 
| union | A ∪ B | `setA.union(setB)` | 
| difference | A - B | `setA - setB` หรือ `setA.difference(setB)` | 

ทั้งสามคำสั่งจะคืนค่าออกมาเป็นเซตใหม่แยกต่างหากจาก `setA` และ `setB` ที่เราใช้ในการเรียกคำสั่ง หลังจากเรียกคำสั่ง set operation แล้ว สมาชิกของ `setA` และ `setB` จะไม่เปลี่ยนแปลง



