# การคิดเชิงคำนวณ (Computational Thinking)
หลักสำคัญของการเขียนโปรแกรมไม่ใช่การจำคำสั่งให้ได้ แต่ว่าเป็นการนำคำสั่งมาประกอบรวมกันเพื่อสั่งให้เครื่องทำงานตามที่เราตั้งใจไว้ได้

เวลาเราได้โจทย์มาหนึ่งโจทย์ เช่น ดึงข้อมูล comment บนโลกโซเชียลลงมาเพื่อวิเคราะห์ว่าคนกำลังสนใจผู้สมัครผู้ว่าฯ คนไหนมากที่สุด จะเห็นว่าเป็นโจทย์ที่ใหญ่มาก ไม่รู้เลยว่าจะเริ่มจากตรงไหนก่อน หลัก Computational thinking เป็นหลักการที่ทำให้เราแก้โจทย์การเขียนโปรแกรมเหล่านี้ ซึ่งประกอบไปด้วย 4 หลัก

1. การย่อยโจทย์ (decomposition) คือ การพิจารณาโจทย์แล้วแจกแจงออกมาว่ามีโจทย์ย่อย ๆ อะไรบ้าง เช่น ถ้าเราต้องการประกอบตู้ลิ้นชักใส่เสื้อผ้า เราจะต้องย่อยเป็นการประกอบลิ้นชัก ประกอบโครงตู้ ประกอบขาตู้ และการประกอบส่วนต่าง ๆ มาเป็นส่วนเดียว
3. การสังเกตหาแพทเทิร์น (pattern recognition) คือ การหาสิ่งที่โจทย์ย่อยนั้นมีเหมือน ๆ กัน เช่น ถ้าเราใช้ตัวอย่างการประกอบตู้ลิ้นชักใส่เสื่อผ้า โจทย์การประกอบตัวลิ้นชักเองมีแพทเทิร์นของมันอยู่ ก็คือเป็นกล่องที่เราต้องขันน็อตทั้งสี่ข้าง และต้องขันมือจับข้างหน้า ไม่ว่าจะเป็นลิ้นชักเล็กหรือใหญ่ ก็จะมีแพทเทิร์นการประกอบเหมือนกันอยู่ เพียงแต่เราต้องหามุมในการขันน็อตให้เจอ
2. การมองแบบนามธรรม (abstraction) คือ การแยกออกมาว่าแก่นสำคัญของโจทย์ทั้งหมดนั้นเป็นอย่างไร เช่น ลิ้นชักทั้งหมดที่มีขายอยู่ในท้องตลาดก็มีจะมีส่วนประกอบเหมือนกันหมด คือรูปทรงเป็นกล่องสี่เหลี่ยม ข้างบนเปิด มีที่จับสำหรับดึงออกมาได้ ซึ่งสิ่งเหล่านี้เป็นส่วนประกอบที่เป็นแก่นของโจทย์การประกอบลิ้นชัก แต่ว่าความกว้าง ความยาว วัสดุของลิ้นชักเอง หรือรูปร่างของหูจับจะเป็นอย่างไรนั้นเป็นรายละเอียดของตู้ลิ้นชักแต่ละยีห่้อ แต่ละขนาด แต่ละประเภท ซึ่งไม่ได้เป็นส่วนหนึ่งของแก่นของโจทย์
4. การออกแบบอัลกอริธึม (algorithm) คือกระบวนการแก้ปัญหาที่มีขั้นตอนชัดเจนจนสามารถสั่งให้เครื่องทำแทนเราได้ เช่น อัลกอริธึมของการประกอบตู้ลิ้นชักใส่เสื้อผ้า คือ 

```
1. ไล่ประกอบขาตู้ แล้วเอาพักไว้ก่อน
2. ประกอบโครงตู้ แล้วเอาพักไว้ก่อน
3. ประกอบผลลัพท์จาก 1 และ 2
4. ถ้าตู้มี k ลิ้นชัก ไล่ประกอบตัวลิ้นชักจนครบ k อัน
5. สอดลิ้นชักทั้ง k อันเข้าไปในโครงตู้
```
สังเกตว่าอัลกอริธึมข้างบนมีการย่อยโจทย์ออกมาเป็นส่วนๆ เพื่อแยกแก้ และมีการ abstraction ออกมาโดยไม่สนว่าลิ้นชักที่ต้องการประกอบนั้นจะมีกี่อันก็ตาม จะมีขนาดไหนก็ตาม อัลกอริธึมนี้ก็จะสามารถแก้ได้

## Karel 

ทักษะการคิดเชิงคำนวณดังตัวอย่างที่ยกขึ้นมานี้เป็นทักษะสำคัญที่สุดในการเขียนโปรแกรมซึ่งเราจะฝึกฝนกันในบทนี้โดยการใช้โปรแกรมที่ชื่อว่าแคเริลตัวแคเริลเป็นหุ่นยนต์ตัวเล็ก ๆ เดินไปเดินมาในโลกสี่เหลี่ยมเล็ก ๆ เราสามารถเขียนภาษาไพธอนให้แคเริลเดินไปตามคำสั่งของเรา เพื่อแก้โจทย์ต่าง ๆ ที่กำหนดได้ เราจะใช้แคเริลเป็นของเล่นในการฝึก computational thinking ก่อนที่จะเร่ิมเขียนเป็นภาษาไพธอนจริง ๆ กับโจทย์จริง ซึ่งจะต้องจำคำสั่งเพ่ิมอีกมาก จุดประสงค์ของการเล่นกับแคเริลช่วยฝึกทักษะการคิดแบบนักเขียนโปรแกรมโดยที่ไม่ต้องจำคำสั่งมากมาย

Karel สามารถเดินไปข้างหน้าได้ทีละก้าว แต่ไม่สามารถทะลุกำแพงได้ ถ้าเดินชนกำแพงโปรแกรมจะเกิด error ซึ่งก็คือแคเริลพัง โจทย์ในโลกของแคเริลจะวางแคเริลไว้ที่จุดเริ่มต้น และกำหนดว่าโลกที่ให้มาขนาดเท่าไร มีกำแพงตรงไหนบ้าง และตัวกระดิ่ง (beeper) อยู่ตรงไหนบ้าง ซึ่งแคเริลสามารถเก็บขึ้นมาหรือวาง beeper ตามจุดต่าง ๆ ได้ แต่ถ้าหากพยายามหยิบ beeper ในจุดที่ไม่มี beeper โปรแกรมก็จะเกิด error เช่นกัน คำสั่งที่ใช้ในการแก้โจทย์มีดังนี้

| คำสั่ง | คำอธิบาย |
|------|---------|
| `move()` |  ส่ังให้แคเริลเดินไปข้างหน้า ถ้าข้างหน้ามีกําแพงมันจะชนและเกิด error |
| `turn_left()` |  สั่งให้แคเริลเลี้ยวซ้าย |
| `put_beeper()` |  วางกระดิ่งหน่ึงอันไว้บนจุดท่ียืนอยู่ |
| `pick_beeper()` |  เก็บกระดิ่งข้ึนมาหน่ึงอันจากจุดท่ียืนอยู่ (ถ้าไม่มีกระดิ่งจะเกิด error |

สั่งการหุ่นยนต์แคเริลด้วยภาษาไพธอน 

```{image} img/karel-ex1.png
:height: 150px
:align: center
```
วิธีการแก้ดังนี้
```python
move()
pick_beeper()
turn_left()
move()
turn_left()
move()
put_beeper()
```

## โปรแกรม ฟังก์ชัน และการย่อยโจทย์
สมมติว่าเรามีโจทย์คือ ให้แคเริลไปหยิบ beeper ตรงหน้าเนินแล้วเดินข้ามเนินไปวาง beeper ที่คอลัมน์ที่ 5 ตามภาพข้างล่าง (ภาพซ้ายคือจุดเริ่มต้น ภาพขวาคือจุดมุ่งหมาย)

```{image} img/karel-ex2.png
:height: 150px
:align: center
```

เป็นโจทย์ที่ยังไม่ต้องคิดอะไรมากมาย สมมติเราเขียนโค้ดไพธอนเก็บไว้ในไฟล์ `my_karel_first.py` ดังนี้
```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
from stanfordkarel import *

def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_left()
    turn_left()
    turn_left()
    move()
    move()
    put_beeper()
    move()

if __name__ == "__main__":
    run_karel_program()
```
ส่วนประกอบของโปรแกรมในไฟล์นี้มีดังนี้

```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
```
 ข้อความที่นำด้วย `#` เรียกว่า comment เขียนเอาไว้เพื่อให้คนอื่นมาอ่าน จะได้ทราบว่าโปรแกรมนี้ทำงานอย่างไร มีข้อควรรู้อะไรบ้าง เผื่อว่าคนอื่นอาจจะนำโปรแกรมของเราไปใช้ต่อ 

 ```python
`from stanfordkarel import *`
```
บอกให้โปรแกรมนี้ import ทุกคำสั่งมาจากไลบรารี `stanfordkarel` 

```python
def main():
    move()
    pick_beeper()
    move()
```
ส่วนนี้เรียกว่าฟังก์ชัน ลักษณะที่สำคัญของฟังก์ชันคือมี
- function header ซึ่งประกอบด้วย
  	- `def` เป็น keyword ที่ใช้สำหรับประกาศฟังก์ชันใหม่ 
	- ชื่อฟังก์ชันซึ่งตามมาหลัง `def` และตามด้วย `():`
- body ของฟังก์ชัน ซึ่งก็คือรายการคำสั่งต่าง ๆ ซึ่งจะต้องมีการย่อหน้า (indent) เข้ามาในทุกบรรทัด เพื่อบอกให้รู้ว่าคำสั่งใน body เป็นส่วนหนึ่งของฟังก์ชันนี้ 

```python
if __name__ == "__main__":
    run_karel_program()
```
ตรงส่วนนี้จะสั่งให้เริ่มต้นที่ฟังก์ชันชื่อ `main` และโหลดหน้าต่างที่มีตัวแคเริลแสดงผลอยู่ ส่วนนี้ของโปรแกรมเราอาจจะยังไม่เข้าใจทั้งหมด แต่ว่าให้ข้ามส่วนนี้ไปก่อน 

เราสังเกตอย่างแรกคือว่าโค้ดของเราค่อนข้างยาวและทำความเข้าใจได้ยาก เราต้องมานั่งวาดรูปและไล่ดูว่าแต่ละส่วนของโค้ดมีไว้ทำอะไร ซึ่งตรงนี้ทำให้เราแก้ไขโค้ดได้ยาก จัดว่าเป็นโค้ดที่ไม่ค่อยดี เราจะทำการสร้างฟังก์ชันขึ้นมาใหม่

ก่อน
```python
def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_left() # <---แทนด้วยฟังก์ชันใหม่
    turn_left() #
    turn_left() #
    move()
    move()
    put_beeper()
    move()
```
หลัง
```python
def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_right() # <---แทนด้วยฟังก์ชันใหม่
    move()
    move()
    put_beeper()
    move()

def turn_right():
	turn_left()
	turn_left()
	turn_left()
```
```{margin} คำศัพท์
การสร้างฟังก์ชัน (function defintion/declaration) คือ เขียนฟังก์ชันขึ้นมาใหม่ และตั้งชื่อของฟังก์ชันเพื่อให้พร้อมกับนำไปใช้

การเรียกฟังก์ชัน (function call) คือการนำฟังก์ชันที่เราได้สร้างไว้เรียบร้อยแล้วมาใช้
```
เราได้สร้างฟังก์ชันใหม่ขึ้น `turn_right()` ซึ่งทำให้โค้ดอ่านง่ายขึ้นเนื่องจากเราลดปริมาณโค้ดที่อยู่ในฟังก์ชัน `main` ลงไป 

เมื่อเราสร้างฟังก์ชันแล้ว เราสามารถเรียกฟังก์ชันนั้น (function call) จากฟังก์ชันอื่น ๆ ได้ วิธีการเรียกคือพิมพ์ชื่อของฟังก์ชันตามด้วย `()` ซึ่งขาดไม่ได้ ดังนั้นคำสั่ง`move()` หรือ `pick_beeper()` คือการเรียกฟังก์ชันเช่นเดียวกัน แต่ว่าฟังก์ชันเหล่านี้เราไม่ต้องตั้งขึ้นมาใหม่ เพราะเราได้ import เข้ามาแล้ว 

สรุปส่วนต่าง ๆ ของฟังก์ชันมีดังนี้
```{image} img/function.png
:height: 150px
:align: center
```

## ข้อควรระวัง
 การสร้างฟังก์ชันต้องมีรูปแบบตามที่ภาษาไพธอนกำหนดทุกประการ เครื่องคอมพิวเตอร์เป็นสิ่งที่ฉลาดแต่ว่าเราต้องสื่อสารกับคอมพิวเตอร์แบบถูกไวยากรณ์ทุกประการ ถ้าหากเราลืมอย่างใดอย่างหนึ่ง จะถือว่าผิดไวยากรณ์และ python interpreter จะโยน error (throw) มาให้เราตอนที่เราพยายามรันโค้ด และหยุดการรันโค้ดทันที เช่น 

 ```
   File "my_first_karel.py", line 5
    move()
       ^
IndentationError: expected an indented block
```
python interpreter โยน `IndentationError` มาให้ถ้าเราลืมกั้นย่อหน้าให้คำสั่ง `move()` ในบรรทัดที่ 5

```
  File "my_first_karel.py", line 4
    def main()
             ^
SyntaxError: invalid syntax
```
python interpreter โยน `SyntaxError` มาให้ถ้าเราลืม`:` ท้าย function header ในบรรทัดที่ 4 เพื่อแจ้งให้ทราบว่าเราเขียนโค้ดผิดไวยากรณ์ หรือถ้าเราลืม `()` ก็จะได้ `SyntaxError` เช่นกัน

```
  File "my_first_karel.py", line 4
    def main:
            ^
SyntaxError: invalid syntax
```
พอเราเรียนรู้การใช้คำสั่งใหม่ ๆ เพิ่มขึ้นเราจะเห็น error ชนิดต่าง ๆ เพิ่มขึ้น ซึ่งคนเขียนโปรแกรมควรจะอ่านเป็นว่า python interpreter พยายามนำอะไรมาฟ้องเราเพื่อให้เราแก้ไข ทำให้โค้ดทำงานได้ถูกต้อง 

## การคิดเชิงคำนวณเพื่อในการเขียนโปรแกรม
ทุกโจทย์การเขียนโปรแกรมที่เราได้มา เราต้องเริ่มจากการทำ decomposition ก่อน เพราะว่าโจทย์เล็กๆ หลายๆ อัน ง่ายกว่าการแก้โจทย์ใหญ่โจทย์เดียว ที่ง่ายกว่าก็เพราะว่าเราสามารถทดสอบ solution ของเราเป็นส่วน ๆ ได้ง่ายขึ้น 

ลองดูตัวอย่างโจทย์ว่าแคเริลยืนอยู่บนถนนที่เป็นหลุมเป็นบ่อที่ต้องเอา beeper ลงไปอุดเพื่อทำให้ถนนเรียบ ๆ เดินง่าย สมมติว่าโลกที่แคเริลเริ่มต้นเป็นแบบภาพซ้ายด้านล่าง พอเรารันโปรแกรมโดยสมบูรณ์แล้วจะออกมาหน้าตาเหมือนกับภาพขวาล่าง

```{image} img/repair-road.png
:height: 200px
:align: center
```
จริงๆ แล้วก็ยังเป็นโจทย์ที่ไม่ได้ยากซับซ้อนมากนัก Solution ที่เราได้มาโดยไม่อาศัยการคิดแบบการคิดเชิงคำนวณเลยจะออกมาประมาณนี้ (เราจะดูเฉพาะฟังก์ชัน `main` และ assume ว่าเราได้ import ไลบรารีต่าง ๆ และเก็บโค้ดลงในไฟล์ .py เป็นที่เรียบร้อยแล้ว)
```python
def main():
	move()
	turn_right()
	move()
	put_beeper()
	turn_right()
	turn_right()
	move()
	turn_right()
	move()
	move()
	move()
	# ไม่สมบูรณ์ยังมีต่ออีก...	
```
สังเกตอย่างแรกคือ เป็นโค้ดที่ยาวเหยียดมาก และเข้าใจได้ยากถ้าเราเลือกโค้ดขึ้นมาสักบรรทัด เราจะบอกไม่ได้เลยว่า ณ จุดนั้นแคเริลยืนอยู่ในไหนในโลก หันหน้าไปทางไหนอยู่ 

```{margin}
การย่อยโจทย์ เป็นขั้นตอนที่ 1 ของการคิดเขิงคำนวณ
```
เราจะลองแก้โจทย์นี้ใหม่อีกรอบโดยการใช้การย่อยโจทย์ โจทย์นี่้ที่จริงแล้วสามารถย่อยลงเป็น 3 โจทย์ย่อย
1. ซ่อมหลุมแรก
2. เดินไปหน้าหลุมไปที่สอง
3. ซ่อมหลุมที่ 2

เราจะแก้โจทย์ย่อยแต่ละโจทย์นี้โดยการใช้ฟังก์ชัน 3 ฟังก์ชันนี้ตามลำดับ
```python
def fill_hole1():
	pass

def move_to_next_hole()
	move()
	move()

def fill_hole2():
	pass
```
คำสั่ง `pass` ใส่ไว้เพื่อจองที่ไว้สำหรับการเขียนโค้ดจริงๆ สำหรับฟังก์ชันนั้น ในกรณีนี้เราเขียนโครงของฟังก์ชันทิ้งไว้ก่อนที่จะเริ่มลงรายละเอียดของแต่ละฟังก์ชันจริง ๆ 

```{margin}
การมองหาแพทเทิร์น เป็นขั้นตอนที่ 2 ของการคิดเขิงคำนวณ
```

แต่ถ้าเราสังเกตดูดี ๆ เราจะเห็นว่าโจทย์ที่ 1 กับโจทย์ที่ 3 เป็นโจทย์เดียวกัน เพราะเป็นแพทเทิร์นเดียวกัน ตามกรอบสีแดงข้างล่าง 

```{image} img/deposed-repair-road.png
:height: 200px
:align: center
```
เพราะฉะนั้นเราสามารถเรียกใช้ฟังก์ชันได้สองรอบ

```python
def main():
	fill_hole()
	move_to_next_hole()
	fill_hole()
	
def fill_hole():
	pass

def move_to_next_hole()
	move()
	move()
```
```{margin}
ยิ่งประหยัดโค้ดลงแค่ไหน ยิ่งทำให้ลดโอกาสที่จะเขียนโปรแกรมที่ผิดพลาดได้มากขึ้น
```
ฟังก์ชัน `main` ดูเรียบง่ายและเข้าใจง่ายกว่าของเดิมเยอะมาก เพราะเราย่อยโจทย์อกมาเป็นส่วนย่อย ๆ รวมกับการมองหาแพทเทิร์น ทำให้ปริมาณโค้ดที่เราต้องเขียนน้อยลงด้วย ทำให้เกิดข้อผิดพลาดน้อยลง

ตอนนี้เท่ากับว่าฟังก์ชันที่ต้องเขียนมีแค่ `fill_hole()` เท่านั้นที่เราจะนำไปใช้ถึง 2 ครั้งโดยที่เราเขียนฟังก์ชันนี้ขึ้นมารอบเดียว ฟังก์ชันนี้เรายังสามารถใช้หลักการย่อยโจทย์เพื่อย่อยลงไปได้อีก 

1. กระโดดลงไปในหลุม
2. วาง beeper
3. กระโดดออกมานอกหลุม

```{margin} คำศัพท์
implement แปลว่า เริ่มเขียนโค้ดจริงๆ หลังจากที่ได้มีคิดคำนวณ วางแผนไว้เรียบร้อยแล้ว ซึ่งตรงกับขั้นตอนที่ 4 ของการคิดเชิงคำนวณ
```
เราสามารถเริ่ม implement อัลกอริธึมได้เลย
```python
def fill_hole():
	jump_in()
	put_beeper()
	jump_out()

def jump_in():
	move()
	turn_right()
	move()

def jump_out():
	turn_around()
	move()
	turn_right()
	move()
```
โค้ดข้างบนนี้ทำให้เราเห็นแพทเทิร์นอีกอย่าง นั่นก็คือ `jump_in()` กับ `jump_out()` มีส่วนที่เหมือนกันอยู่ถึงสามบรรทัด นั่นก็คือ `move() turn_right() move()` นั่นก็คือการเดินเป็นรูปตัว L ทำให้เราสามารถเขียนฟังก์ชันมาใช้ซ้ำๆ ได้อีก

```python
def fill_hole():
	move_L()
	put_beeper()
	jump_out()

def move_L():
	move()
	turn_right()
	move()

def jump_out():
	turn_around()
	moveL()
```


ในการแก้โจทย์แคเริลซ่อมถนนข้อนี้ เราได้ใช้การย่อยโจทย์ การมองหาแพทเทิร์น และการเขียนอัลกอริธึม ซึ่งเป็น 3 ใน 4 ของหลักการคิดเชิงคำนวณ เราได้่ข้ามการมองแบบนามธรรมไปในโจทย์ข้อนี้ เราจะมาแก้โจทย์ที่ยากขึ้นเรื่อย ๆ ซึ่งเราจะเห็นต่อไปว่าขั้นตอนการมองแบบนามธรรมจะมีส่วนช่วยอย่างมาก 

```{margin} คำศัพท์
control flow เป็นลักษณะพิเศษของภาษาคอมพิวเตอร์ท่ีควบคุมลําดับการรันโปรแกรม ว่าบรรทัดไหนเกิดก่อนหลัง ก่ีคร้ัง
```
## Control flow - `for` loop
โปรแกรมที่เราเขียนมาทั้งหมดถึงตอนนี้รันโค้ดจากบรรทัดแรกไปถึงบรรทัดสุดท้าย โดยอาจจะมีการกระโดดไปรันฟังก์ชันย่อยอื่น ๆ บ้าง แต่ว่าก็รันเรียงลำดับจากบรรทัดแรกไปบรรทัดสุดท้าย ภาษาคอมพิวเตอร์มีสิ่งที่เรียกว่า control flow ซึ่งก็คือคำสั่งที่พิเศษที่ทำให้เราเลือกได้ว่าจะรันโค้ดส่วนไหนบ้าง จะรันกี่ครั้ง ทำให้เราเขียนโปรแกรมแก้โจทย์ได้อย่างหลากหลายมากขึ้น 
```python
def main():
	move()
	for i in range(5):
		put_beeper()
		move()
	turn_around()
```
ซึ่งเท่ากับว่าเรารัน code block ที่อยู่ใต้ `for` ทั้งหมด 5 ครั้ง (นักเขียนโปรแกรมมักเรียกว่า *for loop ไป 5 รอบ*) หรือเท่ากับรันโค้ดดังนี้
```python
def main():
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	put_beeper()
	move()
	turn_around()
```
การใช้ `for` loop ทำให้เรารันคำสั่งซ้ำๆ ได้โดยที่เราไม่ต้องเขียนโค้ดซ้ำ ๆ เท่าจำนวนรอบที่เราต้องการรัน และเราต้องรู้ล่วงหน้าว่าเราต้องการรันทั้งหมดจำนวนกี่รอบโดยระบุเข้าไปในโค้ดเลย เมื่อรันโค้ดที่อยู่ใน loop จนครบรอบที่ต้องการแล้วจึงจะรันคำสั่งถัดไปที่อยู่นอก loop (นักโปรแกรมเมอร์เรียกว่า *หลุดออกจาก loop*) สรุปแล้ว `for` loop มี syntax ในการใช้ดังนี้
```
for i in range(จำนวนครั้งที่จะวนซ้ำ):
	คำสั่ง
	คำสั่ง
	คำสั่งอีกหลาย ๆ บรรทัด
```
code block ที่มีคำสั่งที่ต้องการจะวนซ้ำจำเป็นต้องเคาะย่อหน้า (indentation) คล้าย ๆ กับการตั้งฟังก์ชัน เพื่อแยกให้เห็นชัดเจนว่าคำสั่งอะไรบ้างที่อยู่ใต้ `for` loop 


## Control flow - `while` loop
อีก control flow พบได้บ่อยในการเขียนโปรแกรมคือการใช้ `while` loop ซึ่งเป็นการรันคำสั่งวนซ้ำ ๆ เช่นเดียวกับ `for` loop ซึ่งเรากำหนดเงื่อนไขไปเลยว่าให้หลุดออกจาก loop หลังจากวนรันไปแล้วกี่ครั้ง  แต่ว่า `while` loop เรากำหนดเองว่าจะให้หลุดออกจากรูปด้วยเงื่อนไขอะไร 

ตัวอย่าง ถ้าเรามีโจทย์ว่าให้แคเริลวาง beeper บนแถวแรกให้เต็มแต่ยกเว้นริมซ้ายสุด และริมขวาสุด โดยที่จุดเริ่มต้นอยู่ที่มุมซ้ายล่างและแคเริลหันไปทางตะวันออก


```{figure} img/while-ex1.png
:height: 100px
:align: center
---
จุดเริ่มต้น
```

```{figure} img/while-ex2.png
:height: 100px
:align: center
---
จุดหมาย
```

เราจะเห็นแพทเทิร์นว่าแคเริลจะต้องก้าวและวาง beeper ทั้งหมด 6 ครั้งด้วยกัน และก็ก้าวอีกก้าวเพื่อให้จบที่ริมขวาสุด ดังนี้

```python
def main():
	move()
	for i in range(6):
		put_beeper()
		move()
```

เราสังเกตแพทเทิร์นที่เราเจอซ้ำ ๆ คือ แคเริลจะต้องมีการวน loop ก้าว วาง ก้าว วาง ไปเรื่อย ๆ ซึ่งเราควรจะใช้การวนโค้ดในการแก้ปัญหาได้  ถ้าเราเปลี่ยนโจทย์ใหม่ว่า เราไม่ทราบว่าขนาดความกว้างของแถวแรก จึงไม่ทราบว่าต้องวาง beeper ทั้งหมดกี่ครั้ง ซึ่งทำให้เราไม่สามารถใช้ `for` loop ในการแก้โจทย์นี้ได้  ข้อสังเกตนี้ได้มาจากการมองหาแพทเทิร์น (pattern recognition)

```{margin} คำศัพท์
การคิดแบบนามธรรม (abstraction) คือ การคิดแก้ปัญหาโดยหาจุดร่วมของโจทย์ทั้งหมด และละรายละเอียดปลีกย่อยออกไป เพื่อให้เห็นแก่นของโจทย์
```

ในขั้นตอนต่อไป เราควรจะตั้งคำถามว่าโลกของแคเริลที่มีขนาด 8 ช่อง กับโลกขนาด 3 ช่อง กับโลกขนาด 100 ช่องมีอะไรที่เป็นจุดร่วมกันบ้าง ซึ่งจุดร่วมนี้เป็นแก่นสำคัญของโจทย์นี้ การคิดตั้งคำถามในลักษณะนี้เป็นตัวอย่างการคิดแบบนามธรรม (abstraction) ในโจทย์ข้อนี้ที่จริงแล้วเราต้องการวนโค้ดการก้าวและวางจนกว่าแคเริลจะชนกำแพง แล้วเราจะรู้ได้่อย่างไรว่าแคเริลตอนนี้หน้าปะกับกำแพงอยู่หรือไม่ 

แคเริลมีฟังก์ชันที่ใช้ในการตรวจสอบเงื่อนไขสถานะของแคเริลว่าข้างหน้ามีกำแพงขวางอยู่หรือไม่ `front_is_clear()` เราสามารถแก้โจทย์นี้โดยการเปลี่ยนจาก `for` loop เป็น `while` loop พร้อมทั้งกำหนดเงื่อนไขการออกจาก loop ดังนี้

```python
def main():
	move()
	while front_is_clear():
		put_beeper()
		move()
```
เราเปลี่ยน `for i in range(6):` เป็น `while front_is_clear():` ซึ่งแปลว่าก่อนรันวนแต่ละรอบให้เช็คว่าข้างหน้าโล่งมั้ย (`front_is_clear()`) ถ้าโล่งก็ให้รัน code block ข้างล่าง พอรันจบก็เช็คเงื่อนไขอีกครั้ง ถ้่าโล่งก็ให้รัน code block อีกรอบ ทำเช่นนนี้ไปเรื่อย ๆ จนกว่าเงื่อนไขจะไม่เป็นจริงอีกต่อไป ทั้งหมดนี้สามารถคิดเป็นแผนภูมิได้ดังนี้

```{image} img/while-flow-chart.png
:height: 400px
:align: center
```

แคเริลมีฟังก์ชันที่ใช้ในการตรวจสอบเงื่อนไขสถานะของแคเริลทั้งหมดดังนี้

|     คำสั่งตรวจสอบ                 |     คำสั่งที่ตรงข้าม                |     ตรวจสอบอะไร                  |
|--------------------------|-----------------------------|-------------------------------------|
|     `front_is_clear()`     |     `front_is_blocked()`      |     มีกำแพงอยู่ตรงหน้า  แคเริลมั้ย       |
|    `beepers_present()`    |     `no_beepers_present()`    |     มี   beeper ตรงที่แคเริลยืนอยู่มั้ย    |
|     `left_is_clear()`     |     `left_is_blocked()`       |     มีกำแพงอยู่ทางซ้ายของ  แคเริลมั้ย    |
|     `right_is_clear()`     |     `right_is_blocked()`      |     มีกำแพงอยู่ทางขวาของ  แคเริลมั้ย    |
|     `beepers_in_bag()`     |     `no_beepers_in_bag()`     |    แคเริลมี beeper ในกระเป๋ามั้ย     |
|     `facing_north()`       |     `not_facing_north()`      |    แคเริลหันหน้าทางเหนือรึเปล่า       |
|     `facing_south()`       |     `not_facing_south()`      |    แคเริลหันหน้าทางใต้รึเปล่า         |
|     `facing_east()`        |     `not_facing_east()`       |    แคเริลหันหน้าทางตะวันออกรึเปล่า    |
|     `facing_west()`        |     `not_facing_west()`       |    แคเริลหันหน้าทางตะวันตกรึเปล่า     |


เงื่อนไขเหล่านี้เรียกอีกอย่างว่าบูลีน (boolean) ซึ่งแปลว่าสิ่งที่มีค่าเป็นจริงหรือเท็จ 

สรุปคือ syntax ในการใช้ `while` loop มีดังนี้

```
while เงื่อนไข:
	คำสั่ง
	คำสั่ง
	คำสั่งอีกหลาย ๆ บรรทัด
```

## Control flow - `if else elif`
Control flow อีกประเภทหนึ่งที่สำคัญมาก ๆ คือ การเลือกว่าจะรัน code block ใดในเงื่อนไขใดบ้าง 

ตัวอย่าง เช่น ถ้าเราอยากให้แคเริลเดินไปข้างหน้าถ้าด้านหน้าไม่มีอะไรกั้น 
```python
def safe_move():
	if front_is_clear():
		move()
```
เราสามารถใช้เงื่อนไขบูลีนในการกำหนดว่าเราจะรันโค้ดที่อยู่ใน code block ในกรณีใดบ้าง ในส่วนของไวยากรณ์ `if` คล้ายคลึงกับ `while` มาก คือต้องตามด้วยบูลีนที่เป็นเงื่อนไขจากนั้น code block ที่ตามมาต้องมีการเคาะย่อหน้า เพื่อกำหนดให้ชัดเจนว่าคำสั่งส่วนใดบ้างที่ต้องรันถ้าเงื่อนไขเป็นจริง 

ฟังก์ชันข้างต้นสามารถเขียนออกมาเป็นแผนภูมิได้ดังนี้

```{image} img/safe-move-diagram.png
:height: 150px
:align: center
```

ตัวอย่างการใช้ `if` ต่อไปจะเป็นตัวอย่างที่ซับซ้อนขึ้นมาอีกขั้น สมมติว่าเราต้องการให้แคเริลวาง beeper ในช่องที่ไม่มี beeper อยู่ก่อนแล้ว และให้เก็บ beeper ถ้าเกิดว่าในช่องนั้นมี beeper อยู่ก่อนแล้ว เพื่อความง่ายเราจะทำเฉพาะแถวล่างสุดเท่านั้น และแคเริลยืนอยู่แถวล่างสุดอยู่แล้ว 

```{image} img/invert-beeper-world.png
:height: 200px
:align: center
```

เราจะเริ่มแก้ปัญหานี้โดยการย่อยโจทย์และการสังเกตแพทเทิร์นว่า ทุกช่องเราจะทำกระบวนการเดียวกันทั้งหมด เพราะฉะนั้นเราสามารถเขียนฟังก์ชันแยกออกมาเพื่อแก้โจทย์ย่อยในการเก็บและวาง beeper ดังนี้

```python
def invert():
   if beepers_present(): # ถ้ามี beeper
      pick_beeper()		 # ให้เก็บ beeper
   else:				 # มิฉะนั้นแล้ว
      put_beeper()		 # ให้วาง beeper ลงในช่องนั้น 	
```
ในฟังก์ชันนี้เรามีการใช้ `else` ซึ่งแปลว่าถ้าเงื่อนไขที่ตั้งไว้ใน `for` ไม่เป็นจริง จะรัน code block ที่อยู่ใต้ `else` ข้อควรระวังหนึ่งคือ ถ้าเราไม่ได้ใส่ `else` ไว้โค้ดที่ตามมาจะถูกรันในทุกกรณี เราต้องเลือกใช้ให้ถูกต้อง

ฟังก์ชันทางด้านบนสามารถเขียนออกมาเป็นแผนภูมิได้ดังนี้ 

```{image} img/invert-beeper-flow-chart.png
:height: 250px
:align: center
```
ถึงขั้นนี้แล้วเราสามารถแก้โจทย์นี้ต่อไปได้ หากเราเห็นว่าเราไม่ต้องสนใจว่าในช่องนั้นจะมีหรือไม่มี beeper อยู่แล้ว 
```python
def main():
	invert()
```
ตอนนี้เราแก้โจทย์นี้บนช่องแรกได้แล้ว จากนั้นหากเราเห็นว่าเราต้องรัน `invert()` ซ้ำ ๆ ในทุกช่องจนกว่าเราหน้าติดกำแพง ซึ่งแปลว่าเราต้องกำหนดเงื่อนไขที่ทำให้แคเริลรันโค้ดซ้ำ ๆ โดยใช้ `while` loop ดังนี้
```python
def main():
	invert()
	while front_is_clear():
		move()
		invert()
```
ซึ่งทั้งหมดนี้อยากให้เห็นว่าเป็นการใช้การคิดเชิงคำนวณในการแก้ปัญหาโดยใช้การย่อยโจทย์ การสังเกตหาแพทเทิร์น (ต้องทำซ้ำเหมือนกันทุกช่อง) การมองแบบนามธรรม (หาเงื่อนไขในการวน) และการออกแบบอัลกอริธึม (เริ่มเขียนโค้ดรวมกันทั้งหมด) และเราได้ใช้ `while` รวมกับ `if` ซึ่งเป็นเครื่องมือ control flow ที่สำคัญในการเขียนโปรแกรม 

### ข้อแตกต่างระหว่าง `if` กับ `while` 
ผู้เรียนโปรแกรมมือใหม่อาจจะสับสนระหว่าง `if` กับ `while` เนื่องจากไวยากรณ์ค่อนข้างคล้ายกัน แต่ว่าความหมายของทั้งสองคำสั่งนี้ต่างกันพอสมควร กล่าวคือ `if` จะรัน code block ข้างใต้เพียงหนึ่งครั้งเท่านั้น ถ้าเงื่อนไขที่กำหนดเป็นจริง 

เราสามารถสรุปวิธีการใช้ `if` ได้ดังนี้ 
```
def main
    คำสั่ง 1
    if เงื่อนไข
        คำสั่ง 2
        คำสั่ง 3
    คำสั่ง 4

```
```{figure} img/if-vs-while-flow-chart.png
:scale: 25%
:align: left
```

เราสามารถสรุปวิธีการใช้ `while` ได้ดังนี้ เพื่อเปรียบเทียบกันกับ `if` ซึ่งรันคำสั่งเพียงแค่ครั้งเดียว
```
def main
    คำสั่ง 1
    while เงื่อนไข
        คำสั่ง 2
        คำสั่ง 3
    คำสั่ง 4
```
```{figure} img/while-vs-if-flow-chart.png
:scale: 25%
:align: left
```

## บูลีน
การกำหนดเงื่อนไขด้วยบูลีนเป็นเครื่องมือที่สำคัญมากในการเขียนโปรแกรม เราสามารถเขียนเงื่อนไขที่ซับซ้อนขึ้นไปอีกได้โดยใช้โอเปอร์เรเตอร์ทางตรรกศาสตร์ เช่น `or` และ `and` เพื่อให้เห็นการใช้งานที่ชัดขึ้น เราจะลองแก้โจทย์แคเริลอีกหนึ่งข้อ

สมมติว่าเราต้องการให้แคเริลเอา beeper ที่อยู่รอบรั้วออกไปให้หมด ดังตัวอย่างดังนี้
```{figure} img/boolean-remove-fence.png
ซ้าย: จุดเริ่มต้น
ขวา: จุดมุ่งหมาย
```
เราสามารถสังเกตหาแพทเทิร์นได้ว่าการเก็บ beeper แต่ละข้างมีวิธีการเหมือนกันทุกประการ เราสามารถย่อยโจทย์ออกมาเป็นฟังก์ชันที่เก็บ beeper ของหนึ่งข้าง และใช้ฟังก์ชันนั้นซ้ำ ๆ 
```python
def main():
	for i in range(4):
		remove_one_side()
```
จากนั้นเราสามารถมองแบบนามธรรมไปได้ว่า รั้วจะยาวเท่าไรไม่ได้สำคัญ สำคัญว่าเราเห็นว่ามีเงื่อนไขในการตรวจได้ว่าแคเริลยังไม่สุดรั้ว ซึ่งการตรวจหารั้วคือการตรวจสอบว่าฝั่งซ้ายมีกำแพงหรือไม่โดยคำสั่ง `left_is_blocked()` *หรือ* อีกเงื่อนไขหนึ่งคือตรงที่ยืนอยู่มี beeper หรือไม่ด้วยโดยคำสั่ง `beepers_present()` ซึ่งการเชื่อมบูลีนสองตัวด้วย *หรือ* สามารถใช้โอเปอร์เรเตอร์ `or` ลงไปตรง ๆ แบบภาษาอังกฤษได้เลยดังนี้

```python
def remove_one_side():
	while left_is_blocked() or beepers_present():
		if beepers_present():
			pick_beeper()
		move()
```
เพื่อทดสอบว่าตรรกะตามฟังก์ชันนั้นถูกต้องหรือไม่ เราอาจจะเขียนตารางออกมาเพื่อตรวจสอบอีกครั้ง
```{figure} img/or-operation.png
ตัวอย่างการใช้ `or` operator
```
เงื่อนไขด้านล่างสุดแสดงให้เห็นว่าแคเริลได้เดินมาถึงมุมแล้วหรือถึงช่องที่ไม่ได้อยู่ติดกับรั้วอีกต่อไปแล้ว ทำให้ส่งต่อไปยังรั้วอีกข้างที่เหลือต่อไปได้ 

นอกจากนั้นแล้วภาษาไพธอนยังมีโอเปอร์เรเตอร์ `and` ซึ่งมีการตีค่าบูลีนเหมือนกันกับ *และ* ในตรรกศาสตร์ ดังนี้
```{figure} img/and-operation.png
ตัวอย่างการใช้ `and` operator
```

กลับมาที่โจทย์ซึ่งเราสามารถแก้โจทย์สำหรับรั้วหนึ่งข้างได้แล้ว ที่เหลือที่ต้องทำคือเชื่อมให้แคเริลวนโค้ดแบบเดิมกับด้านที่เหลือ 
```python
def main():
	for i in range(4):
		remove_one_side()
		turn_left()
		move()

def remove_one_side():
	while left_is_blocked() or beepers_present():
		if beepers_present():
			pick_beeper()
		move()
```
