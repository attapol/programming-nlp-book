# บทที่ 1 </br> การเขียนโปรแกรม และการคิดเชิงคำนวณ

```{admonition} จุดมุ่งหมายของบทนี้
- ผู้อ่านรู้จักวิธีการคิดเชิงคำนวณ และสามารถคิดเชิงคำนวณได้
- ผู้อ่านสามารถวิเคราะห์และแบ่งปัญหาขนาดใหญ่ออกเป็นส่วนย่อยที่จัดการได้ง่ายขึ้น
- ผู้อ่านเข้าใจหลักการเขียนฟังก์ชันที่สามารถนำกลับมาใช้ซ้ำได้
- ผู้อ่านเข้าใจแนวคิดของการใช้คำสั่งวนซ้ำ `for` และ `while`
- ผู้อ่านสามารถใช้คำสั่ง `if` และ `else` ร่วมกับค่าบูลีนและตัวดำเนินการตรรกะ เช่น `and` และ `or` ได้อย่างถูกต้อง
```
<!-- ใน admolition เดิมมีการกล่าวถึง ตัวดำเนินการตรรกะ 'not' แล้วก็ การใช้ 'break', 'elif' อยู่ด้วย หากแต่ในเนื้อหาไม่ได้ครอบคลุมเนื้อหาสามส่วนนี้ ไม่รู้ว่าควรลบทิ้งหรือไม่ หรือเพิ่ม

ในเบื้องต้นได้ลบชื่อออกจากในหัวข้อและวัตถุประสงค์นำของบทออกแล้ว-->
หลักสำคัญของการเขียนโปรแกรมมิได้อยู่ที่การจดจำคำสั่งทั้งหมด แต่อยู่ที่การนำคำสั่งมาประยุกต์ใช้และประกอบกันอย่างเหมาะสมเพื่อให้ระบบสามารถปฏิบัติงานตามที่ผู้พัฒนาต้องการได้อย่างมีประสิทธิภาพ ซึ่งหลายครั้งโจทย์ที่ผู้พัฒนาต้องการจะแก้หรือตอบโจทย์นั้นอาจเป็นโจทย์ประกอบไปด้วยขอบเขตที่กว้างและซับซ้อน จนยากจะหาจุดเริ่มต้น เช่น 
- *การดึงข้อมูลความคิดเห็นจากโซเชียลมีเดียเพื่อนำมาวิเคราะห์ว่าผู้สมัครรับเลือกตั้งรายใดได้รับความสนใจจากสาธารณชนมากที่สุด*
-	*เขียนแอปพลิเคชันในการวิเคราะห์การใช้ภาษาของข้อความที่กำหนดให้*

การเข้าใจแนวคิดการแก้ปัญหาเชิงคำนวณ (computational thinking) จึงเป็นหลักการสำคัญที่จะช่วยในการแก้โจทย์ลักษณะนี้ โดยการแก้ปัญหาเชิงคำนวณ

ไพทอน (Python) เป็นชื่อภาษาเขียนโปรแกรม (programming language) เป็นภาษาที่ได้รับความนิยมที่สุดในการประมวลผลและวิเคราะห์ข้อมูลต่าง ๆ ไม่ว่าจะเป็นข้อมูลที่เป็นตัวเลข ข้อมูลที่อยู่ในฐานข้อมูลเรียบร้อยแล้ว หรือข้อมูลที่เป็นภาษา  โปรแกรมชิ้นหนึ่งประกอบด้วยชุดคำสั่งที่เราจะเขียนขึ้นเป็นภาษาไพทอน

## การติดตั้งไพทอน

```{margin} คำศัพท์
ตัวแปลคำสั่ง (interpreter) มีหน้าที่แปลคำสั่งจากภาษาโปรแกรมมิ่ง (programming language) เป็นภาษาเครื่อง (machine code) เพื่อทำให้เครื่องเข้าใจและกระทำการ (execute) ตามคำสั่งที่ป้อนเข้าไป

ไลบรารี (library) โค้ดที่คนอื่นเขียนขึ้นมาให้แล้วพร้อมสำหรับใช้เป็นส่วนหนึ่งของโค้ดเราได้ทันที

เทอร์มินัล (Terminal) เป็นโปรแกรมที่ทำให้เราสั่งคอมพิวเตอร์ให้ทำงานต่าง ๆ ได้โดยการพิมพ์คำสั่งและกดปุ่ม Enter  
```


### ติดตั้งโปรแกรม Anaconda
ส่วนประกอบต่าง ๆ ที่จำเป็นในการเขียนโปรแกรมเป็นภาษาไพทอน สามารถดาวน์โหลดพร้อมกันเป็นก้อนเดียวโดยการลงโปรแกรม Anaconda ซึ่งมีเครื่องมือต่าง ๆ ดังต่อไปนี้ 

- Python Interpreter ตัวแปลคำสั่งที่เขียนเป็นภาษาไพทอน เป็นภาษาที่เครื่องคอมพิวเตอร์เข้าใจ เพื่อจะได้นำไปรัน ตามที่เขียนได้ ต้องสังเกตเวอร์ชันที่ใช้ด้วยให้เป็นปัจจุบันที่สุด 

- ไลบรารีภาษาไพทอนหลาย ๆ ตัวที่มักใช้สำหรับการประมวลผล และวิเคราะห์ข้อมูล ทำให้สะดวกสบายในการลงโปรแกรม

- Anaconda prompt คือ Terminal ประเภทหนึ่ง ซึ่งมักจะประกอบด้วยหน้าจอสีดำ ๆ และข้อความที่แสดงผลให้ผู้ใช้พิมพ์คำสั่งลงไป Anaconda prompt ลงไปโดยตรง เราจะใช้เทอร์มินัลในการรันคำสั่งลง library ต่าง ๆ และรันคำสั่งในการไฟล์โค้ดไพทอน

- สิ่งแวดล้อมสำหรับการพัฒนาแบบเบ็ดเสร็จ (Interactive Development Environment หรือ IDE)  เป็นเครื่องมือที่ไว้สำหรับอำนวยความสะดวกในการเขียนโค้ด ส่วนหลักคือหน้าต่างที่ไว้สำหรับพิมพ์โค้ด และบันทึกโค้ดเก็บลงไฟล์ รวมถึงฟีเจอร์อื่น ๆ ที่ทำให้เขียนโค้ดได้อย่างมีประสิทธิภาพมากขึ้น เช่น ปรับเปลี่ยนสีตัวอักษรต่าง ๆ เพื่อให้ดูง่ายขึ้น และสามารถปรับหน้าต่างเพื่อแสดงโค้ดหลาย ๆ ไฟล์ หรือหลาย ๆ หน้า ได้ตามความพอใจ 


```{figure} img/jupyternb.png
ภาพตัวอย่างหน้าต่าง Jupyter notebook
```

  - Jupyter notebook เป็น IDE ที่เรียบง่ายที่สุด และเป็นที่นิยมเป็นอย่างมากในหมู่นักวิเคราะห์ข้อมูล เพราะถูกออกแบบมาเพื่อการวิเคราะห์ข้อมูลโดยเฉพาะ เนื่องจาก Jupyter notebook รองรับการรันโค้ดทีละก้อนเล็ก ๆ และแสดงผลการคำนวณออกมาให้เห็นชัดเจน IDE นี้จึงถูกเรียกว่า notebook เพราะเปรียบเสมือนกับนักวิทยาศาสตร์ข้อมูลทำการวิเคราะห์ข้อมูลและจดบันทึกกระบวนการวิเคราะห์และผลวิเคราะห์ไว้ในสมุด  เพื่อให้ทราบที่มาที่ไปของผลสรุปต่าง ๆ ที่ได้จากการวิเคราะห์ ไฟล์ที่จะสามารถเปิดด้วย Jupyter notebook ได้นั้นจะต้องมีนามสกุลไฟล์ (file extension) เป็น .ipynb

```{figure} img/jupyterlab.png
:height: 300px
:align: center

ภาพตัวอย่างหน้าต่าง JupyterLab
```

  - Jupyterlab เป็น IDE ที่เบาและ feature น้อยกว่า VSCode ทำให้ใช้ได้ไม่ยากนักสำหรับมือใหม่ ถูกออกแบบมาเพื่อการประมวลผลและวิเคราะห์ข้อมูลเป็นจุดประสงค์หลัก เหมาะกับการจัดการกับงานที่ต้องอาจจะต้องใช้ไฟล์ข้อมูล หลายไฟล์ และไฟล์ jupyter notebook (.ipynb) หลาย ๆ ไฟล์ และใช้ Terminal ควบคู่ไปกับการทำงานด้วย

### Visual Studio Code (VSCode)
นอกจากนั้นให้ลงโปรแกรม IDE ที่ชื่อว่า Visual Studio Code (VSCode) 

```{figure} img/vscode.png
:height: 300px
:align: center

ภาพตัวอย่างหน้าต่าง Visual Studio Code
```

Visual Studio Code (VSCode) เป็น IDE ที่มีฟีเจอร์หลากหลายชนิด สามารถปรับรูปลักษณ์ตามความชอบได้หลายแบบ รวมถึงรองรับภาษาโปรแกรมหลายภาษา เหมาะกับการเขียนโปรแกรมที่ประกอบด้วยหลาย ๆ ไฟล์ และต้องมีการตรวจสอบโค้ดอย่างรัดกุม เป็น IDE ที่ดาวน์โหลดได้โดยไม่มีค่าใช้จ่าย และเป็นที่แพร่หลายมากในการเขียนโปรแกรมภาษาไพทอน VSCode สามารถเปิด Terminal ขึ้นมาใช้ในโปรแกรมได้อีกด้วย 

หลังจากติดตั้งเรียบร้อยแล้ว ให้ไปที่ View > Extension จากนั้นพิมพ์ python และติดตั้ง python extension (อย่าลืมเช็คว่าเป็นของ Microsoft)

 ## เขียนโปรแกรมแบบตอบโต้ (Interactive) 
หลังจากที่ลงโปรแกรม Anaconda เรียบร้อยแล้ว เราสามารถเริ่มเขียนโปรแกรมเป็นภาษาไพทอนได้ทันทีเพื่อทดสอบว่าลงโปรแกรมได้โดยสมบูรณ์แล้ว ให้เริ่มจากการเปิด Anaconda Prompt หรือ Anaconda Powershell ก็ได้ซึ่งเป็นเทอร์มินัลสำหรับผู้ที่ใช้ Windows หรือเปิด Terminal App ซึ่งเป็นเทอร์มินัลสำหรับผู้ที่ใช้ Mac จากนั้นให้พิมพ์คำว่า `ipython` ลงไปเพื่อเปิด Interactive Python Interpreter (ipython) และลองพิมพ์
```
 print('Hello, world!')
```
และกด Enter เพื่อทำการส่งคำสั่งที่เขียนเป็นภาษาไพทอนเพื่อให้ Python interpreter  แปลเป็นภาษาเครื่องและรันคำสั่ง จากนั้นหน้าจอจะแสดงผลดังนี้
```
Python 3.7.6 (default, Jan  8 2020, 13:42:34)
Type 'copyright', 'credits' or 'license' for more information
IPython 7.29.0 -- An enhanced Interactive Python. Type '?' for help.

In [1]: print('Hello, world!')
Hello, world!

In [2]:
```
โปรแกรม `ipython` เป็นโปรแกรมที่ทำให้เราสามารถพิมพ์คำสั่งภาษาไพทอนและกดรันเพื่อเห็นผลลัพธ์ได้ทันที ทำให้เราสามารถตอบโต้กับเครื่องไปมาเป็นภาษาไพทอนได้

## เขียนโปรแกรมใส่ไฟล์ และสั่งรันทั้งไฟล์
```{margin} คำศัพท์
Editor โปรแกรมที่ใช้สำหรับเปิดแก้ไขไฟล์
```
ในบางครั้งเราต้องการเขียนโปรแกรมที่ค่อนข้างยาว และต้องการรันโปรแกรมทั้งหมดที่อยู่ในไฟล์  เราสามารถเขียนโปรแกรมโดยการเขียนคำสั่งทั้งหมดใส่ไว้ในไฟล์ก่อน ซึ่งจะต้องมีสกุลไฟล์ `.py` จากนั้นค่อยสั่งให้ Python interpreter แปลและรันคำสั่งทั้งหมดในครั้งเดียว ไล่ไปทีละบรรทัด 

### รันด้วย JupyterLab
วิธีการเขียนโปรแกรมใส่ไฟล์และรันโปรแกรมที่อยู่ในไฟล์นั้นผ่าน JupyterLab มีดังนี้

1. เปิด Anaconda navigator
2. กด Install (ถ้ายังไม่ได้ install) JupyterLab
3. กด Launch JupyterLab
4. กด File -> New -> Python file และตั้งชื่อว่า `myfirstprogram.py` ไฟล์จะถูกเปิดขึ้นบนหน้าต่างใหม่
5. พิมพ์คำว่า `print('Hello, world!')` ใส่ในไฟล์และกด Save 
6. (Mac) กด File -> New -> Terminal เพื่อเปิด Terminal เป็นหน้าต่างใหม่บน JupyterLab (Windows) เปิด Anaconda Powershell 
7. พิมพ์คำว่า `python myfirstprogram.py` ลงไปบนเทอร์มินัล จากนั้นให้กด enter

หน้าต่างเทอร์มินัลจะแสดงคำว่า `Hello, world!` แต่ว่าเทอร์มินัลของแต่ละเครื่องก็จะต่างกันไป
```
$ python myfirstprogram.py
Hello, world!
```

### รันด้วย VS Code
วิธีการเขียนโปรแกรมใส่ไฟล์และรันโปรแกรมที่อยู่ในไฟล์นั้นผ่าน VS Code มีดังนี้

1. เปิด VS Code
2. กด File -> New File และตั้งชื่อว่า `myfirstprogram.py` ไฟล์จะถูกเปิดขึ้นบนหน้าต่างใหม่
3. พิมพ์คำว่า `print('Hello, world!')` ใส่ในไฟล์และกด Save
4. กด Terminal -> New Terminal เพื่อเปิด Terminal เป็นหน้าต่างใหม่บน VS Code
5. พิมพ์คำว่า `python myfirstprogram.py` ลงไปบนเทอร์มินัล จากนั้นให้กด enter

หน้าต่างเทอร์มินัลจะแสดงคำว่า `Hello, world!` แต่ว่าเทอร์มินัลของแต่ละเครื่องก็จะต่างกันไป

## การคิดเชิงคำนวณ

หลักสำคัญของการเขียนโปรแกรมมิได้อยู่ที่การจดจำคำสั่งทั้งหมด แต่เน้นที่การนำคำสั่งมาประยุกต์ใช้และประกอบกันอย่างเหมาะสมเพื่อให้ระบบสามารถปฏิบัติงานตามที่ผู้พัฒนาต้องการได้อย่างมีประสิทธิภาพ เมื่อได้รับโจทย์ เช่น การดึงข้อมูลความคิดเห็นจากโซเชียลมีเดียเพื่อนำมาวิเคราะห์ว่าผู้สมัครรับเลือกตั้งรายใดได้รับความสนใจจากสาธารณชนมากที่สุด หรือเขียนแอปพลิเคชันในการวิเคราะห์การใช้ภาษาของข้อความที่กำหนดให้  จะพบว่าโจทย์ดังกล่าวมีขอบเขตที่กว้างและซับซ้อน จนอาจไม่รู้ว่าจะเริ่มจากจุดไหนก่อน  การแก้ปัญหาเชิงคำนวณ (computational thinking) เป็นหลักการสำคัญที่จะช่วยในการแก้โจทย์ลักษณะนี้ โดยมีองค์ประกอบหลัก 4 ประการ
1. การแบ่งปัญหาออกเป็นส่วนย่อย  (Decomposition) หมายถึง การวิเคราะห์และแบ่งแยกโจทย์ปัญหาออกเป็นส่วนย่อย ๆ เพื่อให้สามารถจัดการและแก้ไขได้ง่ายขึ้น ตัวอย่างเช่น หากเราต้องการประกอบตู้ลิ้นชักใส่เสื้อผ้า กระบวนการนี้สามารถแบ่งออกเป็นขั้นตอนต่าง ๆ ได้แก่ การประกอบลิ้นชัก การประกอบโครงตู้ และการติดตั้งขาตู้ จากนั้นนำแต่ละส่วนมาประกอบรวมกันเป็นตู้ลิ้นชักที่สมบูรณ์

2. การสังเกตหาแบบแผน (Pattern Recognition) หมายถึง การพิจารณาและค้นหาแบบแผนหรือรูปแบบที่เกิดขึ้นซ้ำ ๆ ในปัญหาย่อย ๆ ซึ่งจะช่วยให้สามารถแก้ไขปัญหาได้อย่างมีประสิทธิภาพ เช่น ในกระบวนการประกอบลิ้นชัก แม้ว่าแต่ละลิ้นชักจะมีขนาดแตกต่างกัน แต่ขั้นตอนการประกอบ เช่น การขันน็อตทั้งสี่ด้านและการติดตั้งมือจับ ยังคงมีรูปแบบที่เหมือนกัน

3. การคิดแบบนามธรรม (Abstraction) หมายถึง การระบุแก่นแท้ของปัญหาหรือกระบวนการ โดยตัดรายละเอียดที่ไม่จำเป็นออกไป ตัวอย่างเช่น ลิ้นชักทั้งหมดในตลาดจะมีลักษณะพื้นฐานที่คล้ายกัน คือ เป็นกล่องสี่เหลี่ยม มีฝาด้านหน้าที่สามารถดึงออกได้ ส่วนความแตกต่าง เช่น ขนาด วัสดุ หรือรูปทรงของหูจับ ถือเป็นรายละเอียดที่ไม่เกี่ยวข้องกับแก่นของการประกอบลิ้นชัก

4. การออกแบบอัลกอริทึม (Algorithm Design) หมายถึง การสร้างขั้นตอนหรือกระบวนการในการแก้ปัญหาอย่างชัดเจนและเป็นระบบ เพื่อให้สามารถนำไปปฏิบัติได้ ตัวอย่างเช่น อัลกอริทึมสำหรับการประกอบตู้ลิ้นชักใส่เสื้อผ้าอาจประกอบด้วยขั้นตอนในการประกอบแต่ละชิ้นส่วนและรวมเป็นโครงสร้างที่สมบูรณ์


ตัวอย่างอัลกอริทึมสำหรับการประกอบตู้ลิ้นชักสำหรับใส่เสื้อผ้า ประกอบไปด้วยขั้นตอนดังนี้
```
1. ไล่ประกอบขาตู้ แล้วเอาพักไว้ก่อน
2. ประกอบโครงตู้ แล้วเอาพักไว้ก่อน
3. ประกอบผลลัพธ์จาก 1 และ 2
4. ถ้าตู้มี k ลิ้นชัก ไล่ประกอบตัวลิ้นชักจนครบ k อัน
5. สอดลิ้นชักทั้ง k อันเข้าไปในโครงตู้
```

จะสังเกตได้ว่าอัลกอริทึมดังกล่าวมีการแบ่งแยกโจทย์ออกเป็นส่วนย่อย ๆ เพื่อให้สามารถแก้ไขปัญหาได้ทีละส่วน นอกจากนี้ ยังมีการนำกระบวนการคิดแบบนามธรรมมาใช้ โดยที่อัลกอริทึมไม่จำเป็นต้องคำนึงถึงจำนวนหรือขนาดของลิ้นชักที่ต้องประกอบ ซึ่งทำให้อัลกอริทึมสามารถนำไปประยุกต์ใช้ได้กับลิ้นชักทุกประเภทและทุกขนาด

เช่นเดียวกับการเขียนโปรแกรม ทักษะการคิดเชิงคำนวณเป็นทักษะที่จำเป็นอย่างยิ่งต่อการเขียนโปรแกรม เพราะช่วยให้ผู้พัฒนาสามารถย่อยปัญหาที่ซับซ้อนให้จัดการได้ง่ายขึ้น การสังเกตแบบแผนร่วมและการคิดแบบนามธรรมช่วยให้มองเห็นโครงสร้างหลักของปัญหาได้ชัดเจน และสามารถออกแบบขั้นตอนการทำงานได้อย่างเป็นระบบ จึงสามารถสร้างโปรแกรมที่มีความถูกต้อง ยืดหยุ่น และสามารถนำกลับมาใช้ซ้ำได้ในหลายบริบท เหมือนกับอัลกอริทึมการประกอบลิ้นชักที่สามารถประยุกต์ใช้ได้กับลิ้นชักหลากหลายรูปแบบ โปรแกรมที่ดีเองก็ควรมีความยืดหยุ่นเช่นเดียวกัน

## หุ่นยนต์คาเรล 

ทักษะการคิดเชิงคำนวณตามตัวอย่างที่กล่าวมาข้างต้น ถือเป็นทักษะที่สำคัญยิ่งสำหรับการเขียนโปรแกรม ซึ่งหนึ่งในวิธีที่มีประสิทธิภาพและเป็นการเริ่มต้นที่ดีสำหรับการเริ่มฝึกทักษะดังกล่าวสำหรับผู้เริ่มต้น คือ การฝึกฝนผ่านโปรแกรมคาเรล (Karel) {cite}`pattis1994karel` คาเรลเป็นหุ่นยนต์จำลองขนาดเล็กที่สามารถเคลื่อนที่ไปมาภายในโลกสี่เหลี่ยมที่ถูกกำหนดไว้ โดยผู้ใช้สามารถเขียนโปรแกรมด้วยภาษาไพทอนเพื่อสั่งการคาเรลให้ปฏิบัติตามคำสั่งต่าง ๆ ที่ตั้งไว้สำหรับการแก้โจทย์ในสถานการณ์ที่กำหนดได้ 
 
ในบทนี้ ผู้เรียนจะได้ฝึกฝนทักษะการคิดเชิงคำนวณเบื้องต้นผ่านโปรแกรมคาเรล เพื่อเป็นการวางรากฐานและเสริมสร้างทักษะการคิดเชิงคำนวณ โดยไม่ต้องจดจำคำสั่งจำนวนมาก ก่อนเข้าสู่เนื้อหาการเขียนโปรแกรมภาษาไพทอนที่ซับซ้อนขึ้นในบทถัด ๆ ไป

ในโปรแกรมนี้ หุ่นยนต์คาเรลสามารถเคลื่อนที่ไปข้างหน้าได้ครั้งละหนึ่งก้าว แต่ไม่สามารถทะลุผ่านกำแพงได้ หากคาเรลชนกับกำแพงจะทำให้เกิดข้อผิดพลาดในโปรแกรม (error) และโปรแกรมจะหยุดทำงานทันที โจทย์ในโลกของคาเรลจะเริ่มจากการกำหนดจุดเริ่มต้นของคาเรล ขนาดของโลกที่คาเรลอยู่ รวมถึงตำแหน่งของกำแพงและตำแหน่งของกระดิ่ง (beeper) คาเรลสามารถเก็บหรือวางกระดิ่งในจุดต่าง ๆ ได้ แต่หากพยายามเก็บกระดิ่งในจุดที่ไม่มีกระดิ่งวางอยู่ จะทำให้โปรแกรมเกิดข้อผิดพลาดขึ้นเช่นกัน คำสั่งที่ใช้ในการแก้ปัญหาในโจทย์คาเรลประกอบด้วยคำสั่งดังต่อไปนี้

| คำสั่ง | คำอธิบาย |
|------|---------|
| `move()` |  สั่งให้คาเรลเดินไปข้างหน้า หากข้างหน้ามีกําแพง คาเรลจะชนกำแพงและทำให้โปรแกรมเกิดข้อผิดพลาด |
| `turn_left()` |  สั่งให้คาเรลเลี้ยวซ้าย |
| `put_beeper()` |  วางกระดิ่งหนึ่งอันไว้ตรงจุดที่ยืนอยู่ |
| `pick_beeper()` |  เก็บกระดิ่งขึ้นมาหนึ่งอันจากตรงจุดที่ยืนอยู่ (ถ้าไม่มีกระดิ่งที่จุดนั้น จะทำให้โปรแกรมเกิดข้อผิดพลาด) |

### ตัวอย่าง 
หากคาเรลอยู่ในโลกขนาด 2x2 มีจุดเริ่มต้นอยู่ที่มุมซ้ายล่างของโลกและหันหน้าไปทางทิศตะวันออก และมีจุดหมายคือให้คาเรลเก็บกระดิ่งที่มุมขวาล่าง และไปเดินทางไปยังมุมซ้ายบน ดังภาพข้างล่าง


```{figure} img/karel-ex1.png
:height: 200px
:align: center

ภาพ 1.1 โลกของคาเรลในโจทย์ 1 จุดเริ่มต้นของโจทย์แสดงอยู่ในภาพด้านซ้าย จุดมุ่งหมายของโจทย์แสดงอยู่ในภาพด้านขวา
```

การแก้โจทย์นี้ ต้องอาศัยการนำคำสั่งหลาย ๆ คำสั่งมาต่อกันในลำดับที่เหมาะสมเพื่อให้คาเรลสามารถเก็บกระดิ่งและเดินทางไปยังจุดที่โจทย์กำหนดได้ ดังนี้

```python
move()
pick_beeper()
turn_left()
move()
turn_left()
move()
put_beeper()
```

ถ้าหากโปรแกรมสั่งให้คาเรลชนกำแพง ดังโค้ดข้างล่างนี้
```python
move()
move()
```
โปรแกรมจะเกิดข้อผิดพลาด และจะหยุดทำงานทันที 

หรือถ้าหากโปรแกรมสั่งให้คาเรลหยิบกระดิ่งในจุดที่ไม่มีกระดิ่ง ดังโค้ดข้างล่างนี้
```python
move()
turn_left()
move()
pick_beeper()
```
โปรแกรมจะเกิดข้อผิดพลาด และจะหยุดทำงานทันทีเช่นกัน 

## โปรแกรมและฟังก์ชัน
หากว่าโจทย์ให้คาเรลไปหยิบกระดิ่งตรงหน้าเนินแล้วเดินข้ามเนินไปวางกระดิ่งที่คอลัมน์ที่ 5 ดังภาพที่ 1.2 ด้านล่าง 

```{figure} img/karel-ex2.png
:height: 300px
:align: center

ภาพ 1. 2 โลกของคาเรลในโจทย์ 2 จุดเริ่มต้นของโจทย์แสดงอยู่ในภาพด้านซ้าย จุดมุ่งหมายของโจทย์แสดงอยู่ในภาพด้านขวา
```

โจทย์นี้มีลักษณะที่ซับซ้อนมากขึ้นกว่าโจทย์แรก เนื่องจากต้องใช้คำสั่งหลายบรรทัดในการแก้โจทย์ โดยผู้เรียนจะต้องเขียนโค้ดภาษาไพทอนเพื่อสั่งการคาเรล โดยสามารถเขียนโค้ดไพทอนเก็บไว้ในไฟล์ `my_karel_first.py` ได้ดังนี้
```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
from stanfordkarel import *

def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_left()
    turn_left()
    turn_left()
    move()
    move()
    put_beeper()
    move()

if __name__ == "__main__":
    run_karel_program()
```
ส่วนประกอบของโปรแกรมในไฟล์ `my_karel_first.py`  นี้มีดังนี้

### คอมเมนต์
```python
# โปรแกรมสำหรับแก้โจทย์แรกในบทนี้
```
ข้อความที่นำหน้าด้วยเครื่องหมาย `#` เรียกว่า หมายเหตุ หรือคอมเมนต์ (comment) ซึ่งเป็นการแสดงความคิดเห็นหรือให้ข้อมูลเพิ่มเติมสำหรับผู้อ่านโค้ด โดยผู้เขียนโค้ดมักคอมเมนต์อธิบายการทำงานของโปรแกรมและจุดสำคัญที่ควรทราบ เพื่อให้ผู้ที่นำโค้ดไปใช้งานต่อสามารถเข้าใจการทำงานของโค้ดนั้นได้อย่างชัดเจน นอกจากนี้ การใช้คอมเมนต์ยังเป็นแนวทางในการช่วยเพิ่มความเข้าใจร่วมกันในทีมผู้พัฒนา และช่วยในกรณีที่ต้องกลับมาทบทวนโปรแกรมในภายหลัง

### การนำเข้าไลบรารี
```python
from stanfordkarel import *
```
ไลบรารี (Library) คือ คลังของโค้ดหรือฟังก์ชันที่ถูกเขียนขึ้นล่วงหน้าและรวบรวมไว้เพื่อให้นักพัฒนาสามารถนำไปใช้งานได้โดยไม่ต้องเขียนโค้ดใหม่ตั้งแต่ต้น ไลบรารีมักจะประกอบไปด้วยฟังก์ชัน และเครื่องมือที่ช่วยในการทำงานเฉพาะด้าน ในบทนี้ไลบรารีที่ต้องนำเข้ามาคือ `stanfordkarel` ซึ่งในไลบรารีนี้ประกอบด้วยฟังก์ชันที่ใช้ในการสั่งการคาเรลให้ปฏิบัติงานต่าง ๆ เช่น `move()` และ `put_beeper()`

### การประกาศฟังก์ชัน
```python
def main():
    move()
    pick_beeper()
    move()
```
ส่วนนี้เรียกว่า ฟังก์ชัน โดยฟังก์ชันมีลักษณะสำคัญดังนี้:

- ส่วนหัวของฟังก์ชัน (function header) ประกอบด้วย
  - คำสำคัญ (keyword) `def` ซึ่งใช้สำหรับประกาศฟังก์ชันใหม่
  - ชื่อของฟังก์ชันซึ่งตามหลังคำว่า `def` และปิดท้ายด้วยวงเล็บเปิด-ปิด และโคลอน `():` 
- ส่วนเนื้อหาของฟังก์ชัน (function body) คือ กลุ่มของคำสั่งที่ประกอบอยู่ภายในฟังก์ชัน โดยคำสั่งเหล่านี้จะต้องมีการย่อหน้า (indentation) ในทุกบรรทัด เพื่อบ่งชี้ว่าคำสั่งเหล่านี้เป็นส่วนหนึ่งของฟังก์ชันนั้น

### การกำหนดคำสั่งการรันไฟล์ไพทอน 
```python
if __name__ == "__main__":
    run_karel_program()
```
โปรแกรมตัวอย่างนี้ถูกจัดเก็บในไฟล์ที่มีนามสกุล `.py` ซึ่งเมื่อไฟล์ถูกเรียกใช้ โปรแกรมจะทำงานทั้งไฟล์ โค้ดที่แสดงข้างต้นเป็นการกำหนดลำดับการทำงานของโปรแกรม โดยใช้โครงสร้าง `if __name__ == "__main__":` เพื่อระบุว่า หากโปรแกรมถูกรันโดยตรง ฟังก์ชัน `run_karel_program()` จะถูกเรียกใช้งานก่อน ซึ่งฟังก์ชันนี้มีหน้าที่ในการโหลดหน้าต่างที่แสดงผลหุ่นยนต์คาเรล จากนั้นโปรแกรมจะไปเรียกฟังก์ชัน `main()` ซึ่งได้ถูกประกาศไว้ในไฟล์เดียวกันนี้

<!--comment: เนื้อหาการแบ่งปัญหาออกเป็นส่วนย่อยซ้ำ 2 จุด :1 -->  

## การแบ่งปัญหาออกเป็นส่วนย่อย 

สิ่งแรกที่ผู้เรียนสามารถสังเกตได้จากโค้ด `my_karel_first.py` คือ โค้ดนั้นมีความยาวและเข้าใจยาก ในการเขียนโปรแกรมนั้น ผู้เขียนโปรแกรมจำเป็นต้องวาดแผนภาพและตรวจสอบการทำงานของโค้ดแต่ละส่วนเพื่อทำความเข้าใจ ซึ่งการที่โค้ดมีลักษณะที่ยาวและเข้าใจยากนั้น อาจส่งผลให้ปรับแก้โค้ดได้ยาก โค้ด `my_karel_first.py` นี้จึงนับว่าไม่มีประสิทธิภาพเท่าที่ควร 
ซึ่งในการแก้ปัญหานี้ ผู้เขียนโปรแกรมสามารถสร้างฟังก์ชันใหม่ขึ้นมาเพื่อปรับปรุงโครงสร้างของโค้ดให้มีความชัดเจนและสามารถเข้าใจได้ง่ายขึ้นได้ เช่น 
```python
turn_left()
turn_left()
turn_left()
```
คำสั่งนี้ แท้จริงแล้วเป็นคำสั่งที่สั่งคาเรลหันขวา โดยการสั่งให้หันซ้ายสามครั้ง ดังนั้นผู้เขียนโปรแกรมจึงสามารถสร้างฟังก์ชันใหม่ `turn_right()` ขึ้นมาเพื่อทำให้โค้ดอ่านง่ายขึ้นดังนี้ 

```python
def main():
    move()
    pick_beeper()
    move()
    turn_left()
    move()
    turn_right() #หันขวา ฟังก์ชันใหม่
    move()
    move()
    put_beeper()
    move()

def turn_right():
    turn_left()
    turn_left()
    turn_left()
```
```{margin} คำศัพท์
การสร้างฟังก์ชัน (function definition/declaration) คือ เขียนฟังก์ชันขึ้นมาใหม่ และตั้งชื่อของฟังก์ชันเพื่อให้พร้อมสำหรับการนำไปใช้

การเรียกฟังก์ชัน (function call) คือการนำฟังก์ชันที่ตัวเราได้สร้างไว้เรียบร้อยแล้วมาใช้
```
เพื่อปรับปรุงโครงสร้างของโค้ด ในโค้ดดังกล่าวได้มีการสร้างฟังก์ชันใหม่ชื่อ `turn_right()` ซึ่งมีบทบาทสำคัญในการทำให้โค้ดในฟังก์ชัน `main()` มีความกระชับและชัดเจนมากขึ้น การย้ายคำสั่งออกจากฟังก์ชัน `main()` ไปไว้ในฟังก์ชันย่อยนี้ไม่เพียงแต่ช่วยลดปริมาณโค้ดในฟังก์ชันหลัก แต่ยังช่วยให้สามารถดูแลรักษาและปรับปรุงโค้ดในระยะยาวได้ง่ายและมีประสิทธิภาพมากขึ้นเช่นกัน

หลังจากที่ฟังก์ชันใหม่ถูกสร้างขึ้น ผู้เขียนโปรแกรมสามารถเรียกใช้งานฟังก์ชันจากส่วนต่าง ๆ ของโปรแกรมได้โดยการพิมพ์ชื่อฟังก์ชันตามด้วยเครื่องหมายวงเล็บ `()` ซึ่งเป็นส่วนที่จำเป็นสำหรับการเรียกใช้งานฟังก์ชัน ตัวอย่างเช่น คำสั่ง `turn_right()` หรือฟังก์ชันพื้นฐานอื่น ๆ เช่น `move()` และ `pick_beeper()` เป็นคำสั่งที่ทำงานในลักษณะเดียวกัน แต่สำหรับสองฟังก์ชันหลังนี้ ผู้เขียนโปรแกรมไม่จำเป็นต้องสร้างขึ้นใหม่ เนื่องจากมีการนำเข้าจากไลบรารีที่เกี่ยวข้องแล้วในตอนต้น

สรุปส่วนต่าง ๆ ของฟังก์ชันได้ดังนี้

```{figure} img/function.png
:height: 250px
:align: center

ภาพ 1.3 ส่วนประกอบของฟังก์ชัน
```

## ข้อควรระวังในการเขียนฟังก์ชัน

การสร้างฟังก์ชันในภาษาไพทอนจำเป็นต้องปฏิบัติตามรูปแบบที่ถูกต้องตามกฎไวยากรณ์ (syntax) เนื่องจากภาษาไพทอน เป็นภาษาการเขียนโปรแกรมที่มีโครงสร้างชัดเจนและยึดกับไวยากรณ์อย่างเคร่งครัด การเขียนโค้ดที่มีลักษณะผิดจากไวยากรณ์แม้เพียงเล็กน้อยก็จะส่งผลให้โปรแกรมไม่สามารถทำงานได้ตามที่คาดหมาย ตัวแปลภาษาไพทอนจะตรวจสอบโค้ดเมื่อมีการรันโปรแกรม และหากพบความผิดพลาด
โปรแกรมจะหยุดทำงานทันทีพร้อมแสดงข้อความแจ้งข้อผิดพลาด (error message) ซึ่งศัพท์เทคนิคในการเขียนโปรแกรมเรียกว่าโยน (throw) ข้อผิดพลาด เพื่อช่วยให้ผู้เขียนโปรแกรมสามารถตรวจสอบและแก้ไขโค้ดได้อย่างถูกต้อง
ข้อผิดพลาดที่อาจเกิดขึ้นระหว่างเขียนโปรแกรมมีหลายประเภท ข้อผิดพลาดที่พบได้บ่อยประเภทหนึ่งคือ ข้อผิดพลาดทางไวยากรณ์ (syntax error) เช่น การไม่ได้ใส่วงเล็บ การพิมพ์ชื่อฟังก์ชันผิด หรือการจัดวางบรรทัดโค้ดที่ไม่ถูกต้อง เมื่อพบข้อผิดพลาดเช่นนี้ ตัวแปลภาษาไพทอนก็จะทำการโยน `SyntaxError` ดังตัวอย่างต่อไปนี้
```
  File "my_first_karel.py", line 4
    def main()
             ^
SyntaxError: invalid syntax
```
จากตัวอย่างดังกล่าว ตัวแปลภาษาไพทอนโยน `SyntaxError` มา เพราะว่าผู้เขียนโปรแกรมไม่ได้ใส่ `:` หลังชื่อฟังก์ชัน ในบรรทัดที่ 4 การแจ้งเตือนนี้เพื่อแจ้งให้ทราบว่าผู้เขียนโปรแกรมนั้นเขียนโค้ดผิดไวยากรณ์

อีกตัวอย่างหนึ่งคือ ในกรณีที่ผู้เขียนโปรแกรมลืมใส่วงเล็บเปิดและปิด (`()`) ในท้ายชื่อฟังก์ชัน ก็จะเกิดข้อผิดพลาดทางไวยากรณ์ (`SyntaxError`) ขึ้นมาเช่นเดียวกัน

```
  File "my_first_karel.py", line 4
    def main:
            ^
SyntaxError: invalid syntax
```

ข้อผิดพลาดอีกประเภทที่พบบ่อยสำหรับผู้ที่กำลังเริ่มต้นเขียนโปรแกรมคือ ข้อผิดพลาดในการจัดย่อหน้า (indentation)  ซึ่งหากมีข้อผิดพลาดเกี่ยวกับการจัดย่อหน้า เช่น ย่อหน้าเกิน หรือย่อหน้าขาด ตัวแปลภาษาไพทอนก็จะโยนข้อผิดพลาด `IndentationError` มาให้ ดังตัวอย่างดังนี้

 ```
   File "my_first_karel.py", line 5
    move()
       ^
IndentationError: expected an indented block
```
ตัวแปลภาษาไพทอนโยน `IndentationError` มาให้ถ้าเราลืมกั้นย่อหน้าให้คำสั่ง `move()` ในบรรทัดที่ 5 พร้อมแนะนำวิธีการแก้ว่าอาจจะต้องเพิ่มย่อหน้าให้เป็นบล็อกใหม่ (*expected an indented block*)

เมื่อผู้เขียนโปรแกรมเรียนรู้การใช้คำสั่งใหม่ ๆ มากขึ้น ก็จะเผชิญกับข้อผิดพลาดประเภทต่าง ๆ มากขึ้นเช่นเดียวกัน ผู้เขียนโปรแกรมควรจะสามารถอ่านและทำความเข้าใจได้ว่าตัวแปลภาษาไพทอนนั้นพยายามชี้ให้เห็นถึงข้อผิดพลาดประเภทใด เช่น ข้อผิดพลาดทางไวยากรณ์ (`SyntaxError`) หรือข้อผิดพลาดในเรื่องของคีย์ (`KeyError`) และจะต้องแก้ไขอย่างไรเพื่อให้โปรแกรมสามารถทำงานได้อย่างถูกต้อง ซึ่งในบทต่อ ๆ ไปจะมีการกล่าวถึงข้อผิดพลาดประเภทอื่น ๆ เพิ่มเติม

## การคิดเชิงคำนวณเพื่อในการเขียนโปรแกรม

<!--comment: เนื้อหาการแบ่งปัญหาออกเป็นส่วนย่อยซ้ำ 2 จุด :2 -->  
ในการแก้ปัญหาเกี่ยวกับการเขียนโปรแกรมทุกครั้ง ควรเริ่มต้นจากการแบ่งปัญหาออกเป็นส่วนย่อยก่อนเสมอ ซึ่งการแบ่งปัญหาเป็นส่วนย่อยจะช่วยลดความซับซ้อนของโจทย์ ทำให้ผู้เขียนโปรแกรมสามารถจัดการกับปัญหาแต่ละส่วนได้อย่างเป็นระบบ และยังช่วยให้สามารถทดสอบและตรวจสอบโปรแกรมแต่ละส่วนได้ง่ายและรวดเร็วขึ้น ทำให้สามารถระบุข้อผิดพลาดและปรับปรุงโปรแกรมได้อย่างมีประสิทธิภาพ

ตัวอย่างเช่น หากพิจารณาโจทย์ที่กำหนดให้คาเรลยืนอยู่บนถนนที่มีหลุมบ่อ ซึ่งผู้เขียนโปรแกรมจะต้องวางกระดิ่งลงในหลุมเพื่อทำให้ถนนเรียบและสามารถเดินต่อไปได้ หากตั้งว่าโลกที่คาเรลเริ่มต้นอยู่นั้นเป็นไปตามภาพ 1.3 ซ้ายล่าง หลังจากที่ผู้เขียนโปรแกรมได้รันโปรแกรมเสร็จสมบูรณ์แล้ว ถนนจะมีลักษณะเป็นไปตามภาพขวาล่าง ในกระบวนการนี้ คาเรลต้องตัดสินใจและดำเนินการแก้ปัญหาด้วยการตรวจสอบตำแหน่งของหลุมบ่อ และวางกระดิ่งลงในตำแหน่งที่เหมาะสม ซึ่งลำดับขั้นตอนเหล่านี้เป็นการแก้ไขปัญหาอย่างเป็นระบบ

```{figure} img/repair-road.png
:height: 250px
:align: center

ภาพ 1.4 โลกของคาเรลในโจทย์ 4 จุดเริ่มต้นของโจทย์แสดงอยู่ในภาพด้านซ้าย จุดมุ่งหมายของโจทย์แสดงอยู่ในภาพด้านขวา
```


แท้จริงแล้ว โจทย์นี้ไม่ได้มีความซับซ้อนมากนัก แนวทางการแก้ปัญหาที่ได้มาโดยไม่อาศัยกระบวนการคิดเชิงคำนวณ จะมีลักษณะดังโค้ดด้านล่างนี้ ซึ่งในที่นี้จะหยิบยกขึ้นมาเฉพาะฟังก์ชัน `main()` และสมมติว่าผู้เขียนโปรแกรมได้ดำเนินการนำเข้าไลบรารีที่จำเป็นทั้งหมด และได้บันทึกโค้ดลงในไฟล์ที่มีนามสกุล `.py` แล้ว 



```python
def main():
    move()
    turn_right()
    move()
    put_beeper()
    turn_right()
    turn_right()
    move()
    turn_right()
    move()
    move()
    move()
    # ไม่สมบูรณ์ยังมีต่ออีก...    
```
อย่างไรก็ตาม ควรตระหนักว่าการใช้กระบวนการคิดเชิงคำนวณในการออกแบบโปรแกรมเป็นสิ่งสำคัญที่จะช่วยให้การแก้ปัญหาเป็นไปอย่างมีประสิทธิภาพ โดยเฉพาะในกรณีที่ปัญหามีความซับซ้อนมากขึ้น ข้อสังเกตที่สำคัญคือ โค้ดที่เขียนขึ้นนั้นมีลักษณะที่ยาวและซับซ้อน ทำให้ต้องใช้เวลาในการทำความเข้าใจนาน จากตัวอย่าง หากพิจารณาโค้ดแต่ละบรรทัดโดยแยกออกจากบริบททั้งหมด จะไม่สามารถทราบได้อย่างแน่ชัดว่าคาเรลอยู่ที่ตำแหน่งใดในโลกเสมือน หรือกำลังหันหน้าไปในทิศทางใด การออกแบบโค้ดอย่างมีระบบและแบ่งส่วนการทำงานให้ชัดเจน จะช่วยให้โปรแกรมที่เขียนขึ้นเข้าใจง่ายและตรวจสอบได้ง่ายขึ้น

<!-- margin คำศัพท์ กับ margin เปล่า ๆ มีความแตกต่างกันหรือไม่ หากไม่ ต้องปรับ margin เปล่าให้เป็นลักษณะ ชื่อ (ภาษาอังกฤษ) คำอธิบาย-->
```{margin}
การแบ่งปัญหาออกเป็นส่วนย่อย เป็นขั้นตอนแรกของการคิดเชิงคำนวณ
```

ในกรณีนี้ สามารถทดลองแก้โจทย์ 1.3 ใหม่อีกครั้ง โดยใช้วิธีการแบ่งปัญหาออกเป็นส่วนย่อย ซึ่งเป็นขั้นตอนแรกของกระบวนการคิดเชิงคำนวณ ทำให้การแก้ปัญหามีประสิทธิภาพและเป็นระบบมากขึ้น โดยโจทย์นี้สามารถแยกออกเป็น 3 ปัญหาย่อย ได้แก่

1. การซ่อมหลุมแรก
2. การเดินไปยังหลุมที่สอง
3. การซ่อมหลุมที่สอง

เพื่อแก้ปัญหาย่อยแต่ละข้อ ผู้เขียนโปรแกรมจะต้องสร้างฟังก์ชันเฉพาะสำหรับแต่ละปัญหา ซึ่งจะช่วยให้โค้ดมีความชัดเจนและเข้าใจง่ายขึ้น ฟังก์ชันเหล่านี้จะถูกเรียกใช้ตามลำดับที่กำหนด ทำให้สามารถแก้ปัญหาได้อย่างเป็นระบบและตรวจสอบได้ง่าย


```python
def fill_hole1():
    pass

def move_to_next_hole()
    move()
    move()

def fill_hole2():
    pass
```

คำสั่ง `pass` ใช้เพื่อเว้นตำแหน่งไว้สำหรับการเขียนโค้ดในฟังก์ชันนั้น ๆ ในกรณีนี้ ตัวอย่างเพียงแค่กำหนดโครงสร้างของฟังก์ชันไว้ก่อน โดยยังไม่ได้ลงรายละเอียดของการทำงานจริงของแต่ละฟังก์ชัน คำสั่ง `pass` จึงทำหน้าที่แทนการเขียนโค้ดที่ยังไม่เสร็จสมบูรณ์ ทำให้โปรแกรมสามารถทำงานได้โดยไม่เกิดข้อผิดพลาดในระหว่างที่โค้ดยังอยู่ในขั้นตอนการพัฒนา

```{margin}
การมองหาแบบแผน เป็นขั้นตอนที่ 2 ของการคิดเชิงคำนวณ
```

หากพิจารณาอย่างละเอียด จะพบว่าปัญหาย่อยที่ 1 และปัญหาย่อยที่ 3 มีรูปแบบแบบแผนปัญหาเช่นเดียวกัน และต้องการการแก้ปัญหาที่เหมือนกัน โดยทั้งสองปัญหาเกี่ยวข้องกับการซ่อมแซมหลุมที่อยู่ข้าง ๆ จุดที่คาเรลยืนอยู่ ดังนั้น จึงสามารถใช้ฟังก์ชันเดียวกันในการแก้ไขทั้งสองปัญหาได้ (แต่ต้องให้คาเรลยืนอยู่ที่จุดฝั่งซ้ายของหลุมก่อนเรียกฟังก์ชัน) ซึ่งจะช่วยลดความซ้ำซ้อนของโค้ดรวมถึงทำให้โปรแกรมมีประสิทธิภาพมากขึ้นได้

```{figure} img/deposed-repair-road.png
:height: 250px
:align: center

ภาพ 1.5 กรอบสีแดงแสดงให้ว่าสองปัญหาย่อยมีลักษณะแบบแผนของปัญหาที่เหมือนกัน
```

เพราะฉะนั้นในการแก้ปัญหานี้จะมีการเรียกใช้ฟังก์ชันซ้ำในโค้ด เพื่อแก้ปัญหาย่อยที่มีแบบแผนเดียวกัน ฟังก์ชัน `fill_hole1()` และ `fill_hole2()` จึงถูกแทนที่ด้วยการเรียกฟังก์ชัน `fill_hole()` สองครั้งในตำแหน่งที่เหมาะสมดังนี้

```python
def main():
    fill_hole()
    move_to_next_hole()
    fill_hole()
    
def fill_hole():
    pass

def move_to_next_hole()
    move()
    move()
```

```{margin}
ยิ่งประหยัดการเขียนโค้ดลงแค่ไหน ยิ่งลดโอกาสที่จะเขียนโปรแกรมที่ผิดพลาดลงได้มากขึ้นเท่านั้น
```


ฟังก์ชัน `main` ที่ออกแบบใหม่นี้กระชับและเข้าใจง่ายกว่าฟังก์ชันเดิมอย่างมาก เนื่องจากฟังก์ชันใหม่นี้ได้มีการแบ่งปัญหาออกเป็นส่วนย่อย และนำการสังเกตแบบแผนของปัญหามาช่วยในการลดปริมาณโค้ดที่ต้องเขียนลง ส่งผลให้โค้ดที่แก้ไขนี้เรียบง่ายและลดโอกาสการเกิดข้อผิดพลาดลงได้

สำหรับฟังก์ชันที่ต้องเขียนเพิ่มเติมนั้น มีเพียงฟังก์ชัน `fill_hole()` ซึ่งถูกเรียกใช้สองครั้งในโปรแกรม ผู้เขียนโปรแกรมสามารถใช้หลักการนำโค้ดมาใช้ซ้ำ (code reuse) โดยเขียนฟังก์ชันนี้เพียงครั้งเดียวแล้วนำมาใช้อีกครั้ง นอกจากนี้ ผู้เขียนโปรแกรมยังสามารถนำแนวคิดการแบ่งปัญหาออกเป็นส่วนย่อยมาใช้กับฟังก์ชัน `fill_hole()` เพื่อแยกการทำงานออกเป็นขั้นตอนย่อย ๆ ลงไปอีกได้ ซึ่งจะทำให้โค้ดมีความชัดเจน เป็นระบบ และจัดการได้ง่ายยิ่งขึ้น โดยสามารถแบ่งขั้นตอนย่อยลงไปได้อีก ดังนี้

1. กระโดดลงไปในหลุม
2. วางกระดิ่ง
3. กระโดดออกมานอกหลุม

```{margin} คำศัพท์
อิมพลิเมนต์ (implement) หมายถึงการลงมือเขียนโค้ดจริง ตามที่ได้คิดและวางแผนการแก้ปัญหาเรียบร้อยแล้ว ซึ่งสอดคล้องกับขั้นตอนที่ 4 ของกระบวนการคิดเชิงคำนวณ
```

หลังจากนั้นผู้เขียนโปรแกรมสามารถเริ่มลงมือเขียนโค้ด (อิมพลิเมนต์) อัลกอริทึมในการ `fill_hole()` ได้ดังนี้

<!-- ไม่มีการเขียน function turn_around() มาก่อน ไม่น่าเป็น built-in ถ้า built-in ก็ต้องเติมในตารางแรก-->
```python
def fill_hole():
    jump_in()
    put_beeper()
    jump_out()

def jump_in():
    move()
    turn_right()
    move()

def jump_out():
    turn_around()
    move()
    turn_right()
    move()
```

หากสังเกตโดยละเอียด โค้ดข้างบนนี้มีลักษณะแบบแผนอีกหนึ่งรูปแบบ คือ `jump_in()` กับ `jump_out()` มีส่วนของโค้ดที่เหมือนกันอยู่ถึงสามบรรทัด นั่นก็คือ `move() turn_right() move()` ซึ่งคือแบบแผนการสั่งให้คาเรลเดินเป็นรูปตัวแอล ดังนั้นเพื่อประหยัดพื้นที่และทำให้การเรียกใช้ฟังก์ชันเป็นไปได้อย่างมีประสิทธิภาพมากขึ้น สามารถเขียนฟังก์ชัน `move_L()` มาใช้ซ้ำได้อีก ดังนี้

```python
def fill_hole():
    move_L()
    put_beeper()
    jump_out()

def move_L():
    move()
    turn_right()
    move()

def jump_out():
    turn_around()
    move_L()
```



ในการแก้ปัญหาคาเรลซ่อมถนนข้อนี้ ผู้เขียนโปรแกรมได้ใช้หลักการคิดเชิงคำนวณ 3 ใน 4 ขั้นตอน ได้แก่ การแบ่งปัญหาออกเป็นส่วนย่อย การสังเกตแบบแผน และการออกแบบอัลกอริทึม อย่างไรก็ตาม ในโจทย์ข้อนี้ ไม่ได้มีการใช้การคิดแบบนามธรรมซึ่งเป็นขั้นตอนสำคัญอีกขั้นตอนหนึ่งของกระบวนการคิดเชิงคำนวณ ทั้งนี้ เมื่อผู้เขียนโปรแกรมต้องเผชิญกับปัญหาที่มีความซับซ้อนมากขึ้นในอนาคต จะเห็นได้ว่าการคิดแบบนามธรรมจะเข้ามามีบทบาทสำคัญอย่างยิ่งในการช่วยจัดการกับความซับซ้อนของปัญหา 


## วงวน `for` 

โปรแกรมที่ผู้เรียนได้เขียนมาจนถึงขณะนี้ เป็นโปรแกรมที่มีลักษณะการประมวลผลชุดคำสั่งตั้งแต่บรรทัดแรกไปจนถึงบรรทัดสุดท้าย โดยอาจมีการเรียกใช้ฟังก์ชันย่อยระหว่างการประมวลผล แต่ยังคงเป็นการทำงานตามลำดับจากบรรทัดแรกไปจนถึงบรรทัดสุดท้าย หรือเรียกได้ว่าประมวลผลทั้งหมด แต่ทั้งนี้ ภาษาคอมพิวเตอร์มีสิ่งที่เรียกว่า *โครงสร้างการควบคุม (control flow)* ซึ่งเป็นชุดคำสั่งพิเศษที่ช่วยให้ผู้เขียนโปรแกรมสามารถกำหนดได้ว่าจะประมวลผลโค้ดส่วนใด หรือต้องการประมวลผลจำนวนกี่ครั้ง การใช้โครงสร้างการควบคุมนี้ทำให้ผู้เขียนโปรแกรมสามารถเขียนโปรแกรมเพื่อแก้ปัญหาต่าง ๆ ได้อย่างหลากหลายและครอบคลุมมากยิ่งขึ้น 

```{margin} คำศัพท์
โครงสร้างการควบคุม (control flow) เป็นลักษณะพิเศษของภาษาคอมพิวเตอร์ ที่ควบคุมลําดับการรันโปรแกรม ลำดับว่าบรรทัดไหนเกิดก่อนหลัง และเกิดกี่คร้ัง
```

วงวน `for` เป็นหนึ่งในโครงสร้างการควบคุม ซึ่งควบคุมการทำงานของโปรแกรมให้วนซ้ำ ๆ ตามจำนวนครั้งที่กำหนดไว้ล่วงหน้า ตัวอย่างเช่น ถ้าผู้เขียนโปรแกรมต้องการให้คาเรลวางกระดิ่งลงบนถนนที่มีหลุมบ่อ 5 หลุม โดยที่คาเรลต้องวางกระดิ่งลงในทุก ๆ หลุม โดยเริ่มจากหลุมที่ 1 จนถึงหลุมที่ 5  โค้ดที่เขียนด้วยวงวน `for` จะมีลักษณะดังนี้
<!--code ผิด ต้องลงหลุมก่อนค่อยวาง หรือไม่ก็ต้องเติมรูปให้เห็นภาพชัด ๆ หรือต้องการจะบอกว่าเป็นถนนเรียบ?แล้ววางทุก ๆ ก้าวเว้นก้าว? ทำไมต้องมี turn_around() ตอนท้าย-->
```python
def main():
    move()
    for i in range(5):
        put_beeper()
        move()
    turn_around()
```

ซึ่งหมายความว่า โปรแกรมจะทำการประมวลผลกลุ่มคำสั่ง (code block) ที่อยู่ภายใต้คำสั่ง `for` ทั้งหมด 5 ครั้ง (นักพัฒนาโปรแกรมมักเรียกกระบวนการนี้อย่างไม่เป็นทางการว่า *ฟอร์ (for) ลูปไป 5 รอบ*) หรือเท่ากับว่าตัวโปรแกรมจะทำการประมวลผลโค้ดดังนี้

```python
def main():
    move()
    put_beeper()
    move()
    put_beeper()
    move()
    put_beeper()
    move()
    put_beeper()
    move()
    put_beeper()
    move()
    turn_around()
```

การใช้คำสั่งวงวน `for` ทำให้ผู้เขียนโค้ดสามารถประมวลผลคำสั่งซ้ำ ๆ ได้โดยไม่จำเป็นต้องเขียนโค้ดซ้ำตามจำนวนรอบที่ต้องการประมวลผล ทั้งนี้ในการใช้คำสั่งวงวน `for`  จำเป็นต้องระบุจำนวนรอบที่ต้องการให้โปรแกรมทำงานล่วงหน้าโดยการกำหนดจำนวนรอบไว้ในโค้ด เมื่อโปรแกรมทำการประมวลผลคำสั่งการวนซ้ำจนถึงจำนวนรอบที่กำหนดแล้ว โปรแกรมจะประมวลผลคำสั่งถัดไปที่อยู่นอกโครงสร้างการวนซ้ำ (ซึ่งนักพัฒนาโปรแกรมมักเรียกอย่างไม่เป็นทางการว่า *ออกจากลูป*) โดยสรุป คำสั่งวงวน `for` มีโครงสร้างหรือรูปแบบการใช้งานดังนี้

```python
for i in range(จำนวนครั้งที่จะวนซ้ำ):
    คำสั่งที่ต้องการวนซ้ำ
    คำสั่งที่ต้องการวนซ้ำ
```

<!-- ต้องบอกว่า i คืออะไร ไม่รู้ว่าอธิบายประมาณนี้ได้มั้ย หรือต้องไปอยู่ในเนื้อหาหลัก ไม่ใช่ใน margin-->


```{margin} 
สำหรับ i ใน range(number) นั้นเป็นเสมือนตัวแปรที่ใช้นับรอบของลูป ในการประมวลผลแต่ละครั้ง i ก็จะมีค่าที่เปลี่ยนไปในแต่ละรอบ เพื่อเป็นตัวแปรที่บอกว่าการวนซ้ำนี้เป็นครั้งที่เท่าไหร่ หรือลำดับใด เช่นหาก for i in range(5) i ก็จะมีค่าตั้งแต่ 0-4 ในแต่ละรอบ
```

กลุ่มคำสั่ง (code block) ที่ต้องการให้ทำงานซ้ำภายใต้คำสั่ง `for` จำเป็นต้องมีการจัดย่อหน้า (indentation) ให้เห็นอย่างชัดเจนว่าคำสั่งใดบ้างที่อยู่ภายในโครงสร้างการวนซ้ำ `for` การย่อหน้าเช่นนี้เหมือนกับการกำหนดโครงสร้างภายในฟังก์ชัน ซึ่งช่วยให้โปรแกรมสามารถแยกแยะได้ว่าคำสั่งใดที่เป็นส่วนหนึ่งของการวนซ้ำ และคำสั่งใดที่เป็นส่วนหนึ่งของโปรแกรมที่อยู่นอกการวนซ้ำ

## วงวน `while` 

โครงสร้างการควบคุมอีกประเภทหนึ่งที่พบได้บ่อยในการเขียนโปรแกรมคือการใช้คำสั่ง `while` ซึ่งเป็นการวนซ้ำคำสั่งเช่นเดียวกันกับคำสั่ง `for` โดยลักษณะสำคัญของวงวน `while`  คือผู้เขียนโปรแกรมต้องกำหนดเงื่อนไขให้โปรแกรมวนซ้ำตามที่กำหนด เมื่อเงื่อนไขที่ระบุไม่เป็นจริง โปรแกรมจะหยุดการทำงานของโครงสร้างการวนซ้ำนี้ กล่าวคือคำสั่งวงวน `while` ทำงานโดยการตรวจสอบเงื่อนไขก่อนเสมอว่าเป็นจริงหรือไม่ หากเงื่อนไขเป็นจริง โปรแกรมจะดำเนินการคำสั่งภายในโครงสร้างการวนซ้ำต่อไป และจะหยุดการวนซ้ำ หรือที่เรียกกันว่าหลุดออกจากโครงสร้างเมื่อเงื่อนไขไม่เป็นจริง

ตัวอย่างเช่น หากกำหนดโจทย์ว่าให้คาเรลวางกระดิ่งบนแถวแรกให้ครบ ยกเว้นจุดริมซ้ายสุดและริมขวาสุด โดยที่จุดเริ่มต้นของคาเรลอยู่ที่มุมซ้ายล่าง และหันหน้าไปทางทิศตะวันออก ความท้าทายของโจทย์นี้คือโปรแกรมจะต้องทำงานได้กับโลกที่มีขนาดอย่างน้อยสามคอลัมน์ขึ้นไป ตัวอย่างเช่น 


```{figure} img/while-ex1.png
---
height: 100px
align: center
---
ภาพ 1.6 จุดเริ่มต้นของโจทย์ 5
```

```{figure} img/while-ex2.png
---
height: 100px
align: center
---
ภาพ 1.7 จุดมุ่งหมายของโจทย์ 5
```

จากการสังเกตรูปแบบการทำงานของคาเรลในโจทย์นี้ ผู้เขียนโปรแกรมจะพบรูปแบบการทำงานของคาเรล ที่คาเรลต้องเดินไปข้างหน้าและวางกระดิ่งลงทั้งหมด 6 ครั้งติดต่อกัน จากนั้นจึงต้องเดินไปอีกหนึ่งก้าวเพื่อหยุดที่ริมขวาสุดตามที่โจทย์กำหนด กล่าวคือ คาเรลจะเริ่มต้นที่ตำแหน่งมุมซ้ายล่าง ข้ามช่องแรกที่ไม่ต้องวางกระดิ่ง จากนั้นวางกระดิ่งในแต่ละช่องที่อยู่ถัดไปจนถึงช่องที่หก และในขั้นตอนสุดท้าย คาเรลจะก้าวอีกหนึ่งก้าวเพื่อไปถึงจุดสิ้นสุดของแถวที่ริมขวาสุด โดยไม่วางกระดิ่งที่ตำแหน่งนั้น ดังนี้

```python
def main():
    move()
    for i in range(6):
        put_beeper()
        move()
```

จากรูปแบบข้างต้น จะพบรูปแบบการทำงานที่คาเรลจะต้องเดินและวางกระดิ่งสลับกันไปเรื่อย ๆ ซึ่งลักษณะเช่นนี้เหมาะสมกับการใช้โครงสร้างการวนซ้ำในการแก้ปัญหา ดังโค้ดข้างต้น อย่างไรก็ตาม เนื่องจากโจทย์กำหนดว่าโปรแกรมจะต้องทำงานได้ในโลกทุกขนาดที่มีขนาดอย่างน้อยสามคอลัมน์ขึ้นไป ดังนั้นผู้เขียนโปรแกรมจึงไม่ทราบล่วงหน้าถึงขนาดความกว้างของแถวแรก ซึ่งหมายความว่าผู้เขียนโปรแกรมไม่สามารถระบุจำนวนรอบที่คาเรลต้องวางกระดิ่งได้อย่างแน่นอนล่วงหน้า การใช้วงวน `for` ซึ่งต้องระบุจำนวนรอบล่วงหน้าจึงไม่สามารถตอบโจทย์นี้ได้

คำสั่งวงวน `while` จึงเหมาะสมกว่าในกรณีนี้ เนื่องจากสามารถใช้เงื่อนไขกำหนดการทำงานของคาเรลไปเรื่อย ๆ จนกว่าคาเรลจะถึงขอบขวาสุดของแถว ผู้เขียนโปรแกรมสามารถใช้เงื่อนไขเพื่อควบคุมการทำงานของคาเรลให้เดินและวางกระดิ่งในแต่ละจุดจนกระทั่งถึงจุดสิ้นสุดของแถวได้ โดยไม่ต้องกำหนดจำนวนรอบล่วงหน้า

```{margin} คำศัพท์
การคิดแบบนามธรรม (abstraction) คือ การคิดแก้ปัญหาโดยหาจุดร่วมของโจทย์ทั้งหมด และละรายละเอียดปลีกย่อยออกไป เพื่อให้เห็นแก่นของโจทย์
```
ในขั้นตอนต่อไป ผู้เขียนโปรแกรมควรตั้งคำถามว่า โลกของคาเรลที่มีขนาด 8 ช่อง 3 ช่อง และ 100 ช่อง มีลักษณะร่วมกันอย่างไร การหาจุดร่วมนี้เป็นแก่นสำคัญในการแก้ปัญหา และการตั้งคำถามเช่นนี้ถือเป็นตัวอย่างของการคิดเชิงนามธรรม  ซึ่งเป็นกระบวนการคิดที่ช่วยให้ผู้เขียนโปรแกรมสามารถเข้าใจถึงรูปแบบพื้นฐานของปัญหาได้ 

ในโจทย์นี้ พื้นฐานของปัญหาคือให้คาเรลก้าวเดินและวางกระดิ่งไปเรื่อย ๆ จนกระทั่งถึงกำแพง ดังนั้นประเด็นสำคัญในการแก้ไขปัญหาจึงไม่ใช่ว่า ขนาดของโลกนั้นจะมีกี่ช่อง หรือต้องวนไปกี่ครั้ง หากแต่คือ ผู้เขียนโปรแกรมจะทราบได้อย่างไรว่าข้างหน้าของคาเรลนั้นมีกำแพงอยู่หรือไม่ คาเรลมีฟังก์ชันที่ใช้ตรวจสอบสถานะพื้นที่ด้านหน้าหรือไม่ว่าเป็นพื้นที่ว่างหรือไม่ ซึ่งในที่นี้คาเรลมีฟังก์ชันดังกล่าว คือฟังก์ชัน `front_is_clear()` ซึ่งจะคืนค่า `True` หากด้านหน้าของคาเรลไม่มีสิ่งกีดขวาง และคืนค่า `False` เมื่อด้านหน้ามีกำแพงหรือสิ่งกีดขวาง
แทนที่จะใช้วงวน `for` ซึ่งจำเป็นต้องระบุจำนวนรอบล่วงหน้า ผู้เขียนโปรแกรมสามารถใช้วงวน `while` ร่วมกับฟังก์ชัน `front_is_clear()` เพื่อกำหนดเงื่อนไขให้คาเรลเดินและวางกระดิ่งไปเรื่อย ๆ จนกระทั่งฟังก์ชันนี้คืนค่า `False` ซึ่งหมายความว่าคาเรลได้เดินไปจนถึงกำแพงแล้วได้ ผู้เขียนโปรแกรมสามารถกำหนดเงื่อนไขการออกจากวงวน `while` ได้ดังตัวอย่างโค้ดต่อไปนี้

```python
def main():
    move()
    while front_is_clear():
        put_beeper()
        move()
```
ในกรณีนี้ โค้ดข้างบนได้มีการเปลี่ยน `for i in range(6):` เป็น `while front_is_clear():`  ซึ่งหมายความว่า ก่อนที่โปรแกรมจะทำการประมวลผลในแต่ละรอบของการวนซ้ำ จะมีการตรวจสอบเงื่อนไขว่าพื้นที่ด้านหน้าของคาเรลว่างอยู่หรือไม่ (`front_is_clear()`) หากด้านหน้ายังว่างอยู่ โปรแกรมจะทำการประมวลผลคำสั่งที่อยู่ภายในโครงสร้างการวนซ้ำ เมื่อประมวลผลคำสั่งในแต่ละรอบเสร็จสิ้น โปรแกรมจะตรวจสอบเงื่อนไขอีกครั้ง หากเงื่อนไขยังคงเป็นจริง (ด้านหน้ายังว่าง) โปรแกรมจะวนซ้ำและทำงานตามคำสั่งในโครงสร้างการวนซ้ำอีกหนึ่งครั้ง  กระบวนการนี้จะดำเนินไปเรื่อย ๆ จนกว่าเงื่อนไขจะไม่เป็นจริงอีกต่อไป กล่าวคือ คาเรลจะหยุดเมื่อด้านหน้ามีกำแพง


```{figure} img/while-flow-chart.png
:height: 400px
:align: center

ภาพ 1.8 แผนภูมิการทำงาน (flowchart) ที่แสดงลำดับขั้นตอนการทำงานของโปรแกรมของกรณีคำสั่งวงวน while
```

นอกเหนือจากคำสั่ง `front_is_clear()` แล้ว โปรแกรมคาเรลยังมีฟังก์ชันที่ใช้ในการตรวจสอบเงื่อนไขสถานะของคาเรลทั้งหมดดังนี้

|     คำสั่งตรวจสอบ                 |     คำสั่งที่ตรงข้าม                |     ตรวจสอบอะไร                  |
|--------------------------|-----------------------------|-------------------------------------|
|     `front_is_clear()`     |     `front_is_blocked()`      |     มีกำแพงอยู่ตรงหน้าคาเรลหรือไม่       |
|    `beepers_present()`    |     `no_beepers_present()`    |     มีกระดิ่งตรงจุดที่คาเรลยืนอยู่หรือไม่    |
|     `left_is_clear()`     |     `left_is_blocked()`       |     มีกำแพงอยู่ทางซ้ายของคาเรลหรือไม่    |
|     `right_is_clear()`     |     `right_is_blocked()`      |     มีกำแพงอยู่ทางขวาของคาเรลหรือไม่    |
|     `beepers_in_bag()`     |     `no_beepers_in_bag()`     |    คาเรลมีกระดิ่งในกระเป๋าหรือไม่     |
|     `facing_north()`       |     `not_facing_north()`      |    คาเรลหันหน้าทางทิศเหนือหรือไม่       |
|     `facing_south()`       |     `not_facing_south()`      |    คาเรลหันหน้าทางทิศใต้หรือไม่         |
|     `facing_east()`        |     `not_facing_east()`       |    คาเรลหันหน้าทางทิศตะวันออกหรือไม่    |
|     `facing_west()`        |     `not_facing_west()`       |    คาเรลหันหน้าทางทิศตะวันตกหรือไม่     |

เงื่อนไขเหล่านี้สามารถเรียกได้ว่าเป็น *บูลีน (boolean)* ซึ่งหมายถึงการตรวจสอบค่าที่มีเพียงสองสถานะ คือ *จริง* หรือ *เท็จ* (*True* หรือ *False*) เงื่อนไขบูลีนมีบทบาทสำคัญในการควบคุมการทำงานของโครงสร้างการวนซ้ำและคำสั่งควบคุมอื่น ๆ ในการเขียนโปรแกรมซึ่งจะกล่าวถึงในหัวข้อถัดไป

โดยสรุป โครงสร้างในการใช้คำสั่ง `while` มีดังนี้

```python
while เงื่อนไขบูลีน:
    คำสั่งที่ต้องการให้วนซ้ำ
    คำสั่งที่ต้องการให้วนซ้ำ
```


<!-- ไม่มีเนื้อหาส่วน elif ต้องเปลี่ยนชื่อเอา elif ออก หรือเติมเนื้อหา-->
## การตั้งเงื่อนไขด้วย `if else elif` และตัวปฏิบัติการบูลีน

โครงสร้างควบคุมการทำงานอีกประเภทหนึ่งที่มีความสำคัญมากในการเขียนโปรแกรมคือ การเลือกว่าคำสั่งใดควรได้รับการประมวลผลภายใต้เงื่อนไขที่กำหนด โดยใช้คำสั่ง `if`  ซึ่งช่วยให้โปรแกรมสามารถเลือกรันกลุ่มคำสั่งตามเงื่อนไขที่กำหนดได้

ตัวอย่างเช่น หากผู้เขียนโปรแกรมต้องการให้คาเรลเดินไปข้างหน้า เฉพาะเมื่อด้านหน้าไม่มีสิ่งกีดขวาง ผู้เขียนโปรแกรมสามารถเขียนฟังก์ชัน `safe_move()` เพื่อควบคุมการเดินของคาเรลได้ ดังนี้

```python
def safe_move():
    if front_is_clear():
        move()
```

ในตัวอย่างนี้ ได้มีการใช้เงื่อนไขบูลีน `front_is_clear()` เพื่อกำหนดการทำงานของคาเรล โดยโปรแกรมจะตรวจสอบว่าเงื่อนไขนี้เป็นจริงหรือไม่ ถ้าเงื่อนไขเป็นจริง กล่าวคือด้านหน้าของคาเรลว่าง คาเรลก็จะเดินไปข้างหน้า แต่หากเงื่อนไขนี้ไม่เป็นจริง คาเรลจะไม่เดินไปข้างหน้า การทำงานของคำสั่ง `if`  นี้จะช่วยให้โปรแกรมสามารถตัดสินใจได้ว่าคาเรลควรทำงานอย่างไร ในกรณีเงื่อนไขต่าง ๆ 

โครงสร้างคำสั่ง `if` คล้ายคลึงกับคำสั่ง `while` โดยทั้งสองคำสั่งนี้ทำงานร่วมกับเงื่อนไขบูลีน ข้อแตกต่างคือกรณีของคำสั่ง `if` คำสั่งภายใต้โครงสร้างของ `if` จะถูกประมวลผลเพียงครั้งเดียวเมื่อเงื่อนไขเป็นจริง ในขณะที่คำสั่ง `while` คำสั่งจะถูกวนซ้ำจนกว่าเงื่อนไขจะไม่เป็นจริง การย่อหน้าใต้คำสั่ง if ทำหน้าที่กำหนดขอบเขตของคำสั่งที่ต้องการให้ประมวลผลเมื่อเงื่อนไขเป็นจริงเช่นเดียวกันกับคำสั่งวงวน `for` และ `while`

ภาพที่ 1.9 นี้ แสดงกระบวนการทำงานของฟังก์ชัน `safe_move()` เป็นแผนภูมิเพื่อให้เห็นลำดับขั้นตอนการทำงานของการใช้โครงสร้างคำสั่ง `if`  ได้ดังนี้


```{figure} img/safe-move-diagram.png
:height: 150px
:align: center

ภาพ 1.9 แผนภูมิการทำงาน (flowchart) ที่แสดงลำดับขั้นตอนการทำงานของโปรแกรมของกรณีคำสั่ง if
```



ตัวอย่างต่อไปจะเป็นตัวอย่างการใช้คำสั่ง `if` ที่มีความซับซ้อนขึ้น ในกรณีนี้ โจทย์ต้องการให้คาเรลวางกระดิ่งลงในช่องที่ยังไม่มีกระดิ่งอยู่ก่อนแล้ว  และให้เก็บกระดิ่งออกหากในช่องนั้นมีกระดิ่งวางอยู่แล้ว โดยในตัวอย่างนี้ คาเรลจะทำงานเฉพาะที่แถวล่างสุดเท่านั้น ซึ่งเป็นตำแหน่งแถวที่คาเรลยืนอยู่ในขณะเริ่มต้น

การแก้ปัญหานี้สามารถทำได้โดยการใช้คำสั่ง `if` และ `else` เพื่อแยกแยะสถานการณ์ว่าจำเป็นต้องวางหรือไม่ต้องวางกระดิ่งลงในช่องปัจจุบัน ซึ่งจะทำให้คาเรลสามารถเลือกได้ว่าจะวางกระดิ่งหรือเก็บกระดิ่งตามเงื่อนไขที่กำหนด

```{figure} img/invert-beeper-world.png
:height: 300px
:align: center

ภาพ 1.10 โลกของคาเรลในโจทย์ 6 จุดเริ่มต้นของโจทย์แสดงอยู่ในภาพด้านซ้าย จุดมุ่งหมายของโจทย์แสดงอยู่ในภาพด้านขวา
```

ผู้เขียนโปรแกรมควรเริ่มแก้ปัญหานี้โดยการแบ่งปัญหาออกเป็นส่วนย่อย และสังเกตลักษณะที่เกิดซ้ำกันในแต่ละช่อง หรือที่เรียกว่าเป็นแบบแผน สิ่งที่สังเกตได้คือไม่ว่าคาเรลจะยืนอยู่ช่องใดก็ตาม สิ่งที่คาเรลต้องทำคือตัดสินใจว่าจะเก็บหรือวางกระดิ่งลงบนช่องนั้น และไม่สำคัญว่าโลกของคาเรลในโจทย์จะมีขนาดเท่าไร คาเรลจะทำกระบวนการเดียวกันในทุกช่อง ดังนั้นผู้เขียนโปรแกรมสามารถแยกเขียนฟังก์ชันออกมาเพื่อจัดการการวางและการเก็บกระดิ่งได้ดังนี้

```python
def invert():
   if beepers_present(): # ถ้ามีกระดิ่ง
      pick_beeper()      # ให้เก็บกระดิ่ง
   else:                 # มิฉะนั้นแล้ว
      put_beeper()       # ให้วางกระดิ่งลงในช่องนั้น     
```
ในฟังก์ชัน `invert()` นี้ มีการใช้โครงสร้าง `if`-`else` ซึ่งทำงานโดยการตรวจสอบเงื่อนไข `if` ก่อน หากเงื่อนไขเป็นจริง (มีกระดิ่งอยู่ในช่อง) โปรแกรมจะทำการเก็บกระดิ่งด้วยคำสั่ง `pick_beeper()` แต่หากเงื่อนไขไม่เป็นจริง (ไม่มีกระดิ่ง) โปรแกรมจะดำเนินการตามคำสั่งในส่วน `else` ซึ่งจะทำการวางกระดิ่งในช่องนั้นด้วยคำสั่ง `put_beeper()`

สิ่งที่ควรระวังคือ หากผู้เขียนโปรแกรมไม่ใช้คำสั่ง `else` คำสั่งที่ตามมาจะถูกรันในทุกกรณี ซึ่งอาจทำให้โปรแกรมทำงานไม่ตรงตามที่ผู้เขียนโปรแกรมต้องการ ดังนั้นจึงต้องใช้ `else` ในกรณีที่ต้องการให้โปรแกรมทำงานอย่างใดอย่างหนึ่งชัดเจนในกรณีที่เงื่อนไขไม่เป็นจริง

ขั้นตอนการทำงานของฟังก์ชัน `invert()` สามารถแสดงเป็นแผนภูมิการทำงานได้ดังนี้

```{figure} img/invert-beeper-flow-chart.png
:height: 250px
:align: center

ภาพ 1.9 แผนภูมิการทำงาน (flowchart) ที่แสดงลำดับขั้นตอนการทำงานของโปรแกรมของฟังก์ชัน invert()
```

เมื่อถึงลำดับนี้แล้ว ผู้เขียนโปรแกรมสามารถแก้โจทย์นี้ต่อไปได้ โดยไม่จำเป็นต้องสนใจว่าในช่องนั้นจะมีหรือไม่มีกระดิ่งวางอยู่ ด้วยคำสั่ง `invert()`
```python
def main():
    invert()
```
เมื่อผู้เขียนโปรแกรมสามารถแก้ปัญหาการวางหรือไม่วางกระดิ่งในเบื้องต้นได้แล้ว จะเห็นว่าต้องมีการรันฟังก์ชัน `invert()` ซ้ำ ๆ ในทุกช่อง ก่อนคาเรลจะชนกำแพง จากการที่ต้องทำซ้ำ ๆ หมายความว่ามีรูปแบบที่เป็นแบบแผน ทำให้จำเป็นต้องกำหนดเงื่อนไขที่ทำให้คาเรลรันโค้ดซ้ำ ๆ ได้ โดยการใช้โครงสร้างวงวน `while` ดังนี้
```python
def main():
    invert()
    while front_is_clear():
        move()
        invert()
```

จากโจทย์ตัวอย่างที่ยกตัวอย่างมาทั้งหมด จะเห็นได้ว่าการนำการคิดเชิงคำนวณมาใช้ในการแก้ปัญหา โดยการแบ่งปัญหาใหญ่ออกเป็นส่วนย่อย การสังเกตหาแบบแผนรูปแบบที่เกิดซ้ำ (หาสิ่งที่ต้องเกิดซ้ำหรือทำซ้ำเช่นเดิมตลอด ในที่นี้คือคาเรลต้องตรวจสอบเลือกวางหรือเก็บกระดิ่งเหมือนกันทุกช่อง) การคิดแบบนามธรรม (การหาเงื่อนไขในการวน) และการออกแบบอัลกอริทึม (เขียนโค้ดรวมออกมาทั้งหมด) ร่วมถึงการใช้งานวงวน `while` รวมกับ `if` ซึ่งเป็นโครงสร้างควบคุมที่สำคัญในการเขียนโปรแกรมนั้นทำให้การเขียนโปรแกรมนั้นเป็นไปได้อย่างมีระบบ ไม่ซับซ้อน และเข้าใจได้ง่าย

### ข้อแตกต่างระหว่าง `if` กับ `while` 
ผู้เรียนเขียนโปรแกรมมือใหม่อาจจะสับสนระหว่างคำสั่ง `if` กับคำสั่งวงวน `while` ได้ง่าย เนื่องจากทั้งสองคำสั่งนี้มีลักษณะไวยากรณ์ที่ค่อนข้างคล้ายคลึงกัน หากแต่ความหมายของทั้งสองคำสั่งนี้แตกต่างกันพอสมควร กล่าวคือ `if` จะรันกลุ่มคำสั่งข้างใต้เพียงหนึ่งครั้งเท่านั้น ถ้าเงื่อนไขที่กำหนดเป็นจริง 

สามารถสรุปวิธีการใช้คำสั่ง `if` ได้ดังนี้ 
```
def main
    คำสั่ง 1
    if เงื่อนไข
        คำสั่ง 2
        คำสั่ง 3
    คำสั่ง 4

```
```{figure} img/if-vs-while-flow-chart.png
:scale: 25%
:align: left

ภาพ 1.11 แผนภูมิการทำงาน (flowchart) ที่แสดงลำดับขั้นตอนการทำงานของโปรแกรมของกรณีคำสั่งเงื่อนไข if 
```

และสามารถสรุปวิธีการใช้คำสั่ง `while` ได้ดังนี้ เพื่อเปรียบเทียบกันกับคำสั่ง `if` ซึ่งรันคำสั่งเพียงแค่ครั้งเดียว จะเห็นได้ว่าคำสั่ง `while` จะรันกลุ่มคำสั่งข้างใต้ไปจนกว่าเงื่อนไขที่กำหนดนั้นจะไม่เป็นจริง
```
def main
    คำสั่ง 1
    while เงื่อนไข
        คำสั่ง 2
        คำสั่ง 3
    คำสั่ง 4
```
```{figure} img/while-vs-if-flow-chart.png
:scale: 25%
:align: left

ภาพ 1.12 แผนภูมิการทำงาน (flowchart) ที่แสดงลำดับขั้นตอนการทำงานของโปรแกรมของกรณีคำสั่งเงื่อนไข while
```

## บูลีน
การกำหนดเงื่อนไขด้วยบูลีนเป็นอีกเครื่องมือที่สำคัญมากในการเขียนโปรแกรม ผู้เขียนโปรแกรมสามารถเขียนเงื่อนไขที่ซับซ้อนขึ้นไปอีกได้ โดยใช้โอเปอร์เรเตอร์ทางตรรกศาสตร์ (Logical Operators) หรือที่บางครั้งเรียกว่าตัวดำเนินการทางตรรกศาสตร์ เช่น `or` และ `and` 
เพื่อให้เห็นตัวอย่างการใช้งานตัวดำเนินการทางตรรกศาสตร์ร่วมกับคำสั่งอื่น ๆ ในที่นี้ จะนำเสนอการวิเคราะห์โจทย์คาเรลเพิ่มเติมอีกข้อหนึ่ง

หากว่าโจทย์ต้องการให้คาเรลเอากระดิ่งที่อยู่รอบรั้วออกไปให้หมด ดังตัวอย่าง

```{figure} img/boolean-remove-fence.png


ภาพ 1.13 โลกของคาเรลในโจทย์ 7 จุดเริ่มต้นของโจทย์แสดงอยู่ในภาพด้านซ้าย จุดมุ่งหมายของโจทย์แสดงอยู่ในภาพด้านขวา
```
ผู้เขียนโปรแกรมจะสามารถสังเกตหาแบบแผนได้ว่าการเก็บกระดิ่งแต่ละข้างมีวิธีการเหมือนกันทุกประการ และปัญหานี้สามารถแบ่งออกเป็นส่วนย่อย ออกมาเป็นฟังก์ชันที่เก็บกระดิ่งของหนึ่งข้าง และใช้ฟังก์ชันนั้นซ้ำ ๆ ได้
```python
def main():
    for i in range(4):
        remove_one_side()
```
เมื่อแยกปัญหาออกเป็นส่วนย่อย และมองหาแบบแผนแล้ว ขั้นตอนต่อมาก็คือการคิดแบบนามธรรม ในที่นี้คือ ความยาวของรั้วนั้นไม่สำคัญ สิ่งที่สำคัญคือทำอย่างไรให้รู้ว่าคาเรลยังไปไม่สุดรั้ว ซึ่งในที่นี้ การตรวจสอบว่าฝั่งซ้ายของคาเรลนั้นมีกำแพงหรือไม่ สามารถตรวจสอบได้โดยการใช้คำสั่ง `left_is_blocked()` *หรือ* อีกเงื่อนไขหนึ่งคือ ตรงที่ยืนอยู่มีกระดิ่งหรือไม่ด้วยโดยคำสั่ง `beepers_present()` ซึ่งผู้เขียนโปรแกรมสามารถเชื่อมบูลีนสองตัวได้ด้วย *หรือ* โดยสามารถใช้ตัวดำเนินการ `or` เชื่อมลงไปโดยตรงได้เลย ดังนี้

```python
def remove_one_side():
    while left_is_blocked() or beepers_present():
        if beepers_present():
            pick_beeper()
        move()
```
เพื่อทดสอบว่าตรรกะตามฟังก์ชันนั้นถูกต้องหรือไม่ ผู้เขียนโปรแกรมอาจจะเขียนตารางออกมาเพื่อตรวจสอบอีกครั้ง

```{figure} img/or-operation.png

ภาพ 1.14 ตัวอย่างการใช้ตัวดำเนินการ `or` 

```

เงื่อนไขด้านล่างสุดแสดงให้เห็นว่า เมื่อคาเรลได้เดินมาถึงมุมแล้ว หรือถึงช่องที่ไม่ได้อยู่ติดกับรั้วอีกต่อไปแล้ว ทำให้หลุดออกจากเงื่อนไขวงวน `while`  ทำให้สามารถเขียนโค้ดเพื่อให้คาเรลเดินต่อไปยังรั้วอีกข้างที่เหลือต่อไปได้ 

นอกจากนั้นแล้ว ภาษาไพทอนยังมีตัวดำเนินการ `and` ซึ่งมีการแปลงค่าบูลีนเหมือนกันกับ *และ* ในตรรกศาสตร์ ดังนี้
```{figure} img/and-operation.png

ภาพ 1.15 ตัวอย่างการใช้ตัวดำเนินการ `and`
```
ซึ่งจากโจทย์เอากระดิ่งรอบรั้วให้หมดนี้ จะเห็นได้ว่าจากโค้ดเบื้องต้น คาเรลสามารถแก้โจทย์สำหรับรั้วด้านหนึ่งได้แล้ว ที่ต้องทำในขั้นถัดไปคือการเขียนโค้ดให้คาเรลวนโค้ด และทำเช่นเดิมกับอีก 3 ด้านที่เหลือ ซึ่งสามารถทำได้ดังนี้
```python
def main():
    for i in range(4):
        remove_one_side()
        turn_left()
        move()

def remove_one_side():
    while left_is_blocked() or beepers_present():
        if beepers_present():
            pick_beeper()
        move()
```

## สรุป

ในบทนี้ได้กล่าวถึงความสำคัญของการคิดเชิงคำนวณ พร้อมทั้งแนะนำโปรแกรมคาเรลและยกตัวอย่างการแก้โจทย์เพื่อให้เห็นลักษณะการคิดเชิงคำนวณอย่างเป็นรูปธรรม โดยได้มีการสอนการใช้โครงสร้างควบคุมที่สำคัญ ทั้งวงวน `for` และวงวน `while` สำหรับการทำงานซ้ำ คำสั่ง `if` และ `else` สำหรับการตัดสินใจตามเงื่อนไข ทั้งนี้ยังได้เรียนรู้การใช้ค่าบูลีน (boolean) และตัวดำเนินการทางตรรกะ เช่น `and` และ `or` ซึ่งเป็นพื้นฐานสำคัญในการกำหนดเงื่อนไขของโปรแกรม การเรียนรู้โครงสร้างควบคุมเหล่านี้ช่วยให้ผู้เขียนโปรแกรมสามารถเขียนโปรแกรมที่ควบคุมการทำงานของโปรแกรมให้สอดคล้องกับสถานการณ์จริงได้อย่างแม่นยำและยืดหยุ่น

ตัวอย่างการแก้โจทย์คาเรลที่ได้แสดงไปในบทนี้มีจุดมุ่งหมายจะชี้ให้เห็นว่า การแก้ปัญหาที่ดูซับซ้อนนั้นสามารถทำได้อย่างเป็นระบบ หากผู้เขียนโปรแกรมมีทักษะในการคิดเชิงคำนวณ โดยเฉพาะทักษะทั้ง 4 ได้แก่

1. การแบ่งปัญหาออกเป็นส่วนย่อย

2. การสังเกตหาแบบแผน

3. การคิดแบบนามธรรม

4. การออกแบบอัลกอริทึม


ในบทต่อ ๆ ไป ผู้เรียนจะได้เรียนรู้วิธีการเขียนโปรแกรมภาษาไพทอนที่ซับซ้อนยิ่งขึ้น โดยจะได้นำหลักการคิดเชิงคำนวณและการใช้เงื่อนไขเหล่านี้มาประยุกต์ใช้ เพื่อพัฒนาโปรแกรมที่สามารถรับมือกับสถานการณ์และเงื่อนไขที่หลากหลายได้อย่างเป็นระบบและมีประสิทธิภาพ

## อ้างอิง

```{bibliography}
:style: plain
:filter: docname in docnames
```